From 35c72565ae4150372fd17c8f444cd4cafd3451f5 Mon Sep 17 00:00:00 2001
From: fengmushu <fengmushu@gmail.com>
Date: Sat, 21 Jul 2018 05:30:08 +0800
Subject: [PATCH 1/2] ac200 and sunxi ahub build-in

---
 .../dts/allwinner/sun50i-h6-tempe-a55.dts     |    4 +
 arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi  |  351 +++++
 drivers/clk/sunxi-ng/ccu-sun50i-h6.h          |   20 -
 include/dt-bindings/clock/sun50i-h6-ccu.h     |   20 +
 include/linux/dma/sunxi-dma.h                 |  282 ++++
 include/linux/dma/sunxi/dma-sun50iw6.h        |  107 ++
 include/sound/dmaengine_pcm.h                 |    5 +
 sound/soc/soc-core.c                          |   12 +-
 sound/soc/sunxi/Kconfig                       |   55 +
 sound/soc/sunxi/Makefile                      |   27 +
 sound/soc/sunxi/acx00-codec.c                 | 1314 +++++++++++++++++
 sound/soc/sunxi/acx00-codec.h                 |  355 +++++
 sound/soc/sunxi/sndhdmi.c                     |  391 +++++
 sound/soc/sunxi/spdif-utils.c                 |   78 +
 sound/soc/sunxi/sunxi-sndahub.c               |  407 +++++
 sound/soc/sunxi/sunxi-snddaudio.c             |  353 +++++
 sound/soc/sunxi/sunxi-snddmic.c               |  171 +++
 sound/soc/sunxi/sunxi-sndhdmi.c               |  227 +++
 sound/soc/sunxi/sunxi-sndspdif.c              |  172 +++
 sound/soc/sunxi/sunxi_ahub.c                  |  931 ++++++++++++
 sound/soc/sunxi/sunxi_ahub.h                  |  291 ++++
 sound/soc/sunxi/sunxi_ahub_cpudai.c           |  484 ++++++
 sound/soc/sunxi/sunxi_ahub_daudio.c           | 1000 +++++++++++++
 sound/soc/sunxi/sunxi_dma.c                   |  546 +++++++
 sound/soc/sunxi/sunxi_dma.h                   |   32 +
 sound/soc/sunxi/sunxi_dmic.c                  |  548 +++++++
 sound/soc/sunxi/sunxi_dmic.h                  |  112 ++
 sound/soc/sunxi/sunxi_netlink.c               |  267 ++++
 sound/soc/sunxi/sunxi_spdif.c                 |  830 +++++++++++
 sound/soc/sunxi/sunxi_spdif.h                 |  197 +++
 30 files changed, 9567 insertions(+), 22 deletions(-)
 create mode 100644 include/linux/dma/sunxi-dma.h
 create mode 100644 include/linux/dma/sunxi/dma-sun50iw6.h
 create mode 100644 sound/soc/sunxi/acx00-codec.c
 create mode 100644 sound/soc/sunxi/acx00-codec.h
 create mode 100644 sound/soc/sunxi/sndhdmi.c
 create mode 100644 sound/soc/sunxi/spdif-utils.c
 create mode 100644 sound/soc/sunxi/sunxi-sndahub.c
 create mode 100644 sound/soc/sunxi/sunxi-snddaudio.c
 create mode 100644 sound/soc/sunxi/sunxi-snddmic.c
 create mode 100644 sound/soc/sunxi/sunxi-sndhdmi.c
 create mode 100644 sound/soc/sunxi/sunxi-sndspdif.c
 create mode 100644 sound/soc/sunxi/sunxi_ahub.c
 create mode 100644 sound/soc/sunxi/sunxi_ahub.h
 create mode 100644 sound/soc/sunxi/sunxi_ahub_cpudai.c
 create mode 100644 sound/soc/sunxi/sunxi_ahub_daudio.c
 create mode 100644 sound/soc/sunxi/sunxi_dma.c
 create mode 100644 sound/soc/sunxi/sunxi_dma.h
 create mode 100644 sound/soc/sunxi/sunxi_dmic.c
 create mode 100644 sound/soc/sunxi/sunxi_dmic.h
 create mode 100644 sound/soc/sunxi/sunxi_netlink.c
 create mode 100644 sound/soc/sunxi/sunxi_spdif.c
 create mode 100644 sound/soc/sunxi/sunxi_spdif.h

diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h6-tempe-a55.dts b/arch/arm64/boot/dts/allwinner/sun50i-h6-tempe-a55.dts
index e0187b007..bc7c69681 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h6-tempe-a55.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h6-tempe-a55.dts
@@ -319,6 +319,10 @@
 	};
 };
 
+&ac200_codec {
+	status = "okay";
+};
+
 &uart0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&uart0_ph_pins>;
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi
index f7d2f3dd7..a3833607d 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h6.dtsi
@@ -173,6 +173,11 @@
 				drive-strength = <40>;
 			};
 
+			pwm1_pins: pwm1-pins {
+				pins = "PB19";
+				function = "pwm1";
+			};
+
 			ext_rgmii_pins: rgmii_pins {
 				pins = "PD0", "PD1", "PD2", "PD3", "PD4",
 				       "PD5", "PD7", "PD8", "PD9", "PD10",
@@ -238,6 +243,36 @@
 				drive-strength = <20>;
 				bias-pull-up;
 			};
+
+			daudio0_pins: daudio0@0 {
+				pins = "PH0", "PH1", "PH2", "PH3", "PH4";
+				function = "i2s0";
+			};
+
+			ahub_daudio0_pins: ahub_daudio0@0 {
+				pins = "PH0", "PH1", "PH2", "PH3", "PH4";
+				function = "h_i2s0";
+			};
+
+			daudio2_pins: daudio2@0 {
+				pins = "PG10", "PG11", "PG12", "PG13", "PG14";
+				function = "i2s2";
+			};
+
+			ahub_daudio2_pins: ahub_daudio2@0 {
+				pins = "PG10", "PG11", "PG12", "PG13", "PG14";
+				function = "h_i2s2";
+			};
+
+			daudio3_pins: daudio3@0 {
+				pins = "PB12", "PB13", "PB14", "PB15", "PB16";
+				function = "i2s3";
+			};
+
+			ahub_daudio3_pins: ahub_daudio3@0 {
+				pins = "PB12", "PB13", "PB14", "PB15", "PB16";
+				function = "h_i2s3";
+			};
 		};
 
 		rtc: rtc@07000000 {
@@ -252,6 +287,11 @@
 			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
+		ac200_codec: ac200_codec {
+			compatible = "allwinner,ac200_codec";
+			status = "disabled";
+		};
+
 		mmc0: mmc@4020000 {
 			compatible = "allwinner,sun50i-h6-mmc";
 			reg = <0x04020000 0x1000>;
@@ -566,5 +606,316 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 		};
+
+		pwm: pwm@0300a000 {
+			compatible = "allwinner,sunxi-pwm";
+			reg = <0x0300a000 0x3c>;
+			clocks = <&ccu CLK_BUS_PWM>;
+			// pwm-number = <2>;
+			pwm-number = <1>;
+			pwm-base = <0x0>;
+			// pwms = <&pwm0>, <&pwm1>;
+			pwms = <&pwm1>;
+		};
+
+		// pwm0: pwm0@0300a000 {
+		// 	compatible = "allwinner,sunxi-pwm0";
+		// 	pinctrl-0 = <&>;
+		// 	reg_base = <0x0300a000>;
+		// 	reg_busy_offset = <0x00>;
+		// 	reg_busy_shift = <28>;
+		// 	reg_enable_offset = <0x00>;
+		// 	reg_enable_shift = <4>;
+		// 	reg_clk_gating_offset = <0x00>;
+		// 	reg_clk_gating_shift = <6>;
+		// 	reg_bypass_offset = <0x00>;
+		// 	reg_bypass_shift = <9>;
+		// 	reg_pulse_start_offset = <0x00>;
+		// 	reg_pulse_start_shift = <8>;
+		// 	reg_mode_offset = <0x00>;
+		// 	reg_mode_shift = <7>;
+		// 	reg_polarity_offset = <0x00>;
+		// 	reg_polarity_shift = <5>;
+		// 	reg_period_offset = <0x04>;
+		// 	reg_period_shift = <16>;
+		// 	reg_period_width = <16>;
+		// 	reg_active_offset = <0x04>;
+		// 	reg_active_shift = <0>;
+		// 	reg_active_width = <16>;
+		// 	reg_prescal_offset = <0x00>;
+		// 	reg_prescal_shift = <0>;
+		// 	reg_prescal_width = <4>;
+		// };
+
+		pwm1: pwm1@0300a000 {
+			compatible = "allwinner,sunxi-pwm1";
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&pwm1_pins>;
+			reg_base = <0x0300a000>;
+			reg_busy_offset = <0x00>;
+			reg_busy_shift = <29>;
+			reg_enable_offset = <0x00>;
+			reg_enable_shift = <19>;
+			reg_clk_gating_offset = <0x00>;
+			reg_clk_gating_shift = <21>;
+			reg_bypass_offset = <0x00>;
+			reg_bypass_shift = <24>;
+			reg_pulse_start_offset = <0x00>;
+			reg_pulse_start_shift = <23>;
+			reg_mode_offset = <0x00>;
+			reg_mode_shift = <22>;
+			reg_polarity_offset = <0x00>;
+			reg_polarity_shift = <20>;
+			reg_period_offset = <0x08>;
+			reg_period_shift = <16>;
+			reg_period_width = <16>;
+			reg_active_offset = <0x08>;
+			reg_active_shift = <0>;
+			reg_active_width = <16>;
+			reg_prescal_offset = <0x00>;
+			reg_prescal_shift = <15>;
+			reg_prescal_width = <4>;
+		};
+
+		// s_pwm: s_pwm@07020c00 {
+		// 	compatible = "allwinner,sunxi-s_pwm";
+		// 	reg = <0x07020c00 0x3c>;
+		// 	clocks = <&r_ccu CLK_R_APB1_PWM>;
+		// 	pwm-number = <1>;
+		// 	pwm-base = <0x10>;
+		// 	pwms = <&spwm0>;
+		// };
+
+		// spwm0: spwm0@07020c00 {
+		// 	compatible = "allwinner,sunxi-pwm16";
+		// 	pinctrl-0 = <&>;
+		// 	reg_base = <0x07020c00>;
+		// 	reg_busy_offset = <0x00>;
+		// 	reg_busy_shift = <28>;
+		// 	reg_enable_offset = <0x00>;
+		// 	reg_enable_shift = <4>;
+		// 	reg_clk_gating_offset = <0x00>;
+		// 	reg_clk_gating_shift = <6>;
+		// 	reg_bypass_offset = <0x00>;
+		// 	reg_bypass_shift = <9>;
+		// 	reg_pulse_start_offset = <0x00>;
+		// 	reg_pulse_start_shift = <8>;
+		// 	reg_mode_offset = <0x00>;
+		// 	reg_mode_shift = <7>;
+		// 	reg_polarity_offset = <0x00>;
+		// 	reg_polarity_shift = <5>;
+		// 	reg_period_offset = <0x04>;
+		// 	reg_period_shift = <16>;
+		// 	reg_period_width = <16>;
+		// 	reg_active_offset = <0x04>;
+		// 	reg_active_shift = <0>;
+		// 	reg_active_width = <16>;
+		// 	reg_prescal_offset = <0x00>;
+		// 	reg_prescal_shift = <0>;
+		// 	reg_prescal_width = <4>;
+		// };
+
+		ahub_daudio0:ahub_daudio0@0x05097000{
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x0 0x05097000 0x0 0xADF>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_AUDIO_HUB>;
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&ahub_daudio0_pins>;
+			pinconfig = <0x1>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x04>;
+			audio_format = <0x01>;
+			signal_inversion = <0x01>;
+			tdm_config = <0x01>;
+			tdm_num = <0x0>;
+			mclk_div = <0x0>;
+			status = "disable";
+		};
+
+		ahub_daudio1:ahub_daudio1@0x05097000{
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x0 0x05097000 0x0 0xADF>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_AUDIO_HUB>;
+			pinconfig = <0x0>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x04>;
+			audio_format = <0x01>;
+			signal_inversion = <0x01>;
+			tdm_config = <0x01>;
+			tdm_num = <0x1>;
+			mclk_div = <0x0>;
+			status = "okay";
+		};
+
+		ahub_daudio2:ahub_daudio2@0x05097000{
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x0 0x05097000 0x0 0xADF>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_AUDIO_HUB>;
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&ahub_daudio2_pins>;
+			pinconfig = <0x1>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x04>;
+			audio_format = <0x01>;
+			signal_inversion = <0x01>;
+			tdm_config = <0x01>;
+			tdm_num = <0x2>;
+			mclk_div = <0x0>;
+			status = "okay";
+		};
+
+		ahub_daudio3:ahub_daudio3@0x05097000{
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x05097000 0xADF>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_AUDIO_HUB>;
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&ahub_daudio3_pins>;
+			pinconfig = <0x1>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x04>;
+			audio_format = <0x01>;
+			signal_inversion = <0x01>;
+			tdm_config = <0x01>;
+			tdm_num = <0x3>;
+			mclk_div = <0x4>;
+			status = "okay";
+		};
+
+		daudio0:daudio@0x05090000 {
+			compatible = "allwinner,sunxi-daudio";
+			reg = <0x05090000 0x74>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_BUS_I2S0>;
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&daudio0_pins>;
+			pcm_lrck_period =  <0x20>;
+			slot_width_select =  <0x20>;
+			daudio_master =  <0x04>;
+			audio_format =  <0x01>;
+			signal_inversion =  <0x01>;
+			tdm_config =  <0x01>;
+			frametype = <0x00>;
+			tdm_num = <0x00>;
+			mclk_div = <0x00>;
+			status = "disabled";
+		};
+
+		audiohdmi:daudio@0x05091000 {
+			compatible = "allwinner,sunxi-tdmhdmi";
+			reg = <0x05091000 0x74>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_BUS_I2S1>;
+			status = "disabled";
+		};
+
+		daudio2:daudio@0x05092000 {
+			compatible = "allwinner,sunxi-daudio";
+			reg = <0x05092000 0x74>;
+		    clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_BUS_I2S2>;
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&daudio2_pins>;
+			pcm_lrck_period =  <0x20>;
+			slot_width_select =  <0x20>;
+			daudio_master =  <0x04>;
+			audio_format =  <0x01>;
+			signal_inversion =  <0x01>;
+			tdm_config =  <0x01>;
+			frametype = <0x00>;
+			tdm_num = <0x2>;
+			mclk_div = <0x0>;
+			status = "disabled";
+		};
+
+		daudio3:daudio@0x0508f000{
+			compatible = "allwinner,sunxi-daudio";
+			reg = <0x0508f000 0x74>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_BUS_I2S3>;
+			pinctrl-names = "default","sleep";
+			pinctrl-0 = <&daudio3_pins>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x04>;
+			audio_format = <0x01>;
+			signal_inversion = <0x01>;
+			tdm_config = <0x01>;
+			frametype = <0x00>;
+			tdm_num = <0x3>;
+			mclk_div = <0x0>;
+			status = "disabled";
+		};
+
+		snddaudio0:sound@0{
+			compatible = "allwinner,sunxi-daudio0-machine";
+			sunxi,daudio-controller = <&daudio0>;
+			sunxi,cpudai-controller = <&ahub_daudio0>;
+			status = "disable";
+		};
+
+		sndhdmi:sound@1{
+			compatible = "allwinner,sunxi-hdmi-machine";
+			sunxi,hdmi-controller = <&audiohdmi>;
+			sunxi,cpudai-controller = <&ahub_daudio1>;
+			status = "okay";
+		};
+
+		snddaudio2:sound@2{
+			compatible = "allwinner,sunxi-daudio2-machine";
+			sunxi,daudio-controller = <&daudio2>;
+			sunxi,cpudai-controller = <&ahub_daudio2>;
+			status = "okay";
+		};
+
+		snddaudio3:sound@3{
+			compatible = "allwinner,sunxi-daudio3-machine";
+			sunxi,daudio-controller = <&daudio3>;
+			sunxi,cpudai-controller = <&ahub_daudio3>;
+			/* acx00-codec throught mfd_add_devices */
+			sunxi,snddaudio-codec = "acx00-codec";
+			sunxi,snddaudio-codec-dai = "acx00-dai";
+			status = "okay";
+		};
+
+		ahub_cpudai0:cpudai0-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x0>;
+			status = "okay";
+		};
+
+		ahub_cpudai1:cpudai1-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x1>;
+			status = "okay";
+		};
+
+		ahub_cpudai2:cpudai2-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x2>;
+			status = "okay";
+		};
+
+		ahub_codec:ahub_codec@0x05097000{
+			compatible = "allwinner,sunxi-ahub";
+			reg = <0x05097000 0xADF>;
+			clocks = <&ccu CLK_PLL_AUDIO>,<&ccu CLK_AUDIO_HUB>;
+			status = "okay";
+		};
+
+		sndahub:sound@6{
+			compatible = "allwinner,sunxi-ahub-machine";
+			sunxi,cpudai-controller0 = <&ahub_cpudai0>;
+			sunxi,cpudai-controller1 = <&ahub_cpudai1>;
+			sunxi,cpudai-controller2 = <&ahub_cpudai2>;
+			sunxi,audio-codec = <&ahub_codec>;
+			status = "okay";
+		};
 	};
 };
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-h6.h b/drivers/clk/sunxi-ng/ccu-sun50i-h6.h
index dd0fae673..199424748 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-h6.h
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-h6.h
@@ -14,26 +14,6 @@
 #define CLK_PLL_CPUX		1
 #define CLK_PLL_DDR0		2
 
-/* PLL_PERIPH0 exported for PRCM */
-
-#define CLK_PLL_PERIPH0_2X	4
-#define CLK_PLL_PERIPH0_4X	5
-#define CLK_PLL_PERIPH1		6
-#define CLK_PLL_PERIPH1_2X	7
-#define CLK_PLL_PERIPH1_4X	8
-#define CLK_PLL_GPU		9
-#define CLK_PLL_VIDEO0		10
-#define CLK_PLL_VIDEO0_4X	11
-#define CLK_PLL_VIDEO1		12
-#define CLK_PLL_VIDEO1_4X	13
-#define CLK_PLL_VE		14
-#define CLK_PLL_DE		15
-#define CLK_PLL_HSIC		16
-#define CLK_PLL_AUDIO_BASE	17
-#define CLK_PLL_AUDIO		18
-#define CLK_PLL_AUDIO_2X	19
-#define CLK_PLL_AUDIO_4X	20
-
 /* CPUX clock exported for DVFS */
 
 #define CLK_AXI			22
diff --git a/include/dt-bindings/clock/sun50i-h6-ccu.h b/include/dt-bindings/clock/sun50i-h6-ccu.h
index f7ddb2410..7162143f1 100644
--- a/include/dt-bindings/clock/sun50i-h6-ccu.h
+++ b/include/dt-bindings/clock/sun50i-h6-ccu.h
@@ -9,6 +9,26 @@
 
 #define CLK_PLL_PERIPH0		3
 
+/* PLL_PERIPH0 exported for PRCM */
+
+#define CLK_PLL_PERIPH0_2X	4
+#define CLK_PLL_PERIPH0_4X	5
+#define CLK_PLL_PERIPH1		6
+#define CLK_PLL_PERIPH1_2X	7
+#define CLK_PLL_PERIPH1_4X	8
+#define CLK_PLL_GPU		9
+#define CLK_PLL_VIDEO0		10
+#define CLK_PLL_VIDEO0_4X	11
+#define CLK_PLL_VIDEO1		12
+#define CLK_PLL_VIDEO1_4X	13
+#define CLK_PLL_VE		14
+#define CLK_PLL_DE		15
+#define CLK_PLL_HSIC		16
+#define CLK_PLL_AUDIO_BASE	17
+#define CLK_PLL_AUDIO		18
+#define CLK_PLL_AUDIO_2X	19
+#define CLK_PLL_AUDIO_4X	20
+
 #define CLK_CPUX		21
 
 #define CLK_APB1		26
diff --git a/include/linux/dma/sunxi-dma.h b/include/linux/dma/sunxi-dma.h
new file mode 100644
index 000000000..32fe631ce
--- /dev/null
+++ b/include/linux/dma/sunxi-dma.h
@@ -0,0 +1,282 @@
+/*
+ * include/linux/dma/sunxi-dma.h
+ *
+ * Copyright (C) 2013-2015 Allwinnertech Co., Ltd
+ *
+ * Author: Sugar <shuge@allwinnertech.com>
+ *
+ * Sunxi DMA controller driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/*
+ * The source DRQ type and port corresponding relation
+ *
+ */
+#ifndef __SUNXI_DMA_H__
+#define __SUNXI_DMA_H__
+
+#include <linux/dmaengine.h>
+
+// #if defined(CONFIG_ARCH_SUN8IW10)
+// #include "sunxi/dma-sun8iw10.h"
+// #elif defined(CONFIG_ARCH_SUN8IW11)
+// #include "sunxi/dma-sun8iw11.h"
+// #elif defined(CONFIG_ARCH_SUN8IW17)
+// #include "sunxi/dma-sun8iw17.h"
+// #elif defined(CONFIG_ARCH_SUN50IW2P1)
+// #include "sunxi/dma-sun50iw2.h"
+// #elif defined(CONFIG_ARCH_SUN50IW3P1)
+// #include "sunxi/dma-sun50iw3.h"
+// #elif defined(CONFIG_ARCH_SUN50IW6P1)
+#if 1
+#include "sunxi/dma-sun50iw6.h"
+// #elif defined(CONFIG_ARCH_SUN3IW1P1)
+// #include "sunxi/dma-sun3iw1.h"
+#else
+
+#define DRQSRC_SRAM		0
+#define DRQSRC_SDRAM		0
+
+#if !defined(CONFIG_ARCH_SUN8IW5) \
+	&& !defined(CONFIG_ARCH_SUN8IW3) \
+	&& !defined(CONFIG_ARCH_SUN8IW8) \
+	&& !defined(CONFIG_ARCH_SUN8IW9)
+#define DRQSRC_SPDIFRX		2
+#endif
+
+#if !defined(CONFIG_ARCH_SUN8IW9)
+#define DRQSRC_DAUDIO_0_RX	3
+#endif
+
+#if !defined(CONFIG_ARCH_SUN9I) \
+	&& !defined(CONFIG_ARCH_SUN8IW8)
+#define DRQSRC_DAUDIO_1_RX	4
+#define DRQSRC_NAND0		5
+#endif
+
+#define DRQSRC_UART0RX		6
+#define DRQSRC_UART1RX 		7
+#define DRQSRC_UART2RX		8
+
+#ifndef CONFIG_ARCH_SUN8IW8
+#define DRQSRC_UART3RX		9
+#define DRQSRC_UART4RX		10
+#endif
+/* #define DRQSRC_RESEVER		11 */
+/* #define DRQSRC_RESEVER		12 */
+
+#ifndef CONFIG_ARCH_SUN9I
+
+#ifdef CONFIG_ARCH_SUN8IW1
+#define DRQSRC_HDMI_DDC		13
+#define DRQSRC_HDMI_AUDIO	14
+#endif
+
+#if !defined(CONFIG_ARCH_SUN8IW6)
+#define DRQSRC_AUDIO_CODEC	15
+#if defined(CONFIG_ARCH_SUN50I)
+#define DRQSRC_CODEC		DRQSRC_AUDIO_CODEC
+#endif
+#endif
+
+#if !defined(CONFIG_ARCH_SUN8IW3) \
+	&& !defined(CONFIG_ARCH_SUN8IW6)
+#define DRQSRC_SS		16
+#if defined(CONFIG_ARCH_SUN50I)
+#define DRQSRC_CE_RX		DRQSRC_SS
+#endif
+#endif
+
+#define DRQSRC_OTG_EP1		17
+#define DRQSRC_OTG_EP2		18
+#define DRQSRC_OTG_EP3		19
+#define DRQSRC_OTG_EP4		20
+
+#if !defined(CONFIG_ARCH_SUN8IW8)
+#define DRQSRC_OTG_EP5		21
+#endif
+
+#else
+#define DRQSRC_AC97		18
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW1) \
+	|| defined(CONFIG_ARCH_SUN9I)
+#define DRQSRC_UART5RX		22
+#endif
+
+#define DRQSRC_SPI0RX		23
+
+#if !defined(CONFIG_ARCH_SUN8IW8)
+#define DRQSRC_SPI1RX		24
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW1) \
+	|| defined(CONFIG_ARCH_SUN9I)
+#define DRQSRC_SPI2RX		25
+#define DRQSRC_SPI3RX		26
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW1)
+#define DRQSRC_TP		27
+#define DRQSRC_NAND1		28
+#define DRQSRC_MTC_ACC		29
+#define DRQSRC_DIGITAL_MIC	30
+
+#elif defined(CONFIG_ARCH_SUN8IW6) \
+	|| defined(CONFIG_ARCH_SUN8IW7)
+
+#define DRQDST_TDMRX		28
+#endif
+
+
+/*
+ * The destination DRQ type and port corresponding relation
+ *
+ */
+#define DRQDST_SRAM		0
+#define DRQDST_SDRAM		0
+
+#if !defined(CONFIG_ARCH_SUN8IW5) \
+	&& !defined(CONFIG_ARCH_SUN8IW5) \
+	&& !defined(CONFIG_ARCH_SUN8IW8)
+#define DRQDST_SPDIFTX		2
+#endif
+
+#if !defined(CONFIG_ARCH_SUN8IW9)
+#define DRQDST_DAUDIO_0_TX	3
+#endif
+
+#if !defined(CONFIG_ARCH_SUN8IW8) \
+	&& !defined(CONFIG_ARCH_SUN8IW9)
+#define DRQDST_DAUDIO_1_TX	4
+#endif
+
+#if !defined(CONFIG_ARCH_SUN9I) \
+	&& !defined(CONFIG_ARCH_SUN8IW8)
+#define DRQDST_NAND0		5
+#endif
+
+#define DRQDST_UART0TX		6
+#define DRQDST_UART1TX 		7
+#define DRQDST_UART2TX		8
+
+#if !defined(CONFIG_ARCH_SUN8IW8)
+#define DRQDST_UART3TX		9
+#define DRQDST_UART4TX		10
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW3) \
+	|| defined(CONFIG_ARCH_SUN8IW5) \
+	|| defined(CONFIG_ARCH_SUN8IW8) \
+	|| defined(CONFIG_ARCH_SUN8IW9)
+#define DRQSRC_TCON0		12
+#endif
+
+#ifndef CONFIG_ARCH_SUN9I
+
+#if defined(CONFIG_ARCH_SUN8IW1)
+#define DRQDST_HDMI_DDC		13
+#define DRQDST_HDMI_AUDIO	14
+#endif
+
+#if !defined(CONFIG_ARCH_SUN8IW6)
+#define DRQDST_AUDIO_CODEC	15
+#if defined(CONFIG_ARCH_SUN50I)
+#define DRQDST_CODEC		DRQDST_AUDIO_CODEC
+#endif
+#endif
+
+#if !defined(CONFIG_ARCH_SUN8IW3) \
+	&& !defined(CONFIG_ARCH_SUN8IW6)
+#define DRQDST_SS		16
+#if defined(CONFIG_ARCH_SUN50I)
+#define DRQDST_CE_TX		DRQDST_SS
+#endif
+#endif
+
+#define DRQDST_OTG_EP1		17
+#define DRQDST_OTG_EP2		18
+#define DRQDST_OTG_EP3		19
+#define DRQDST_OTG_EP4		20
+#if !defined(CONFIG_ARCH_SUN8IW8)
+#define DRQDST_OTG_EP5		21
+#endif
+
+#else
+#define DRQDST_CIR_TX		15
+#define DRQDST_AC97		18
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW1) \
+	|| defined(CONFIG_ARCH_SUN9I)
+#define DRQDST_UART5TX		22
+#endif
+
+#define DRQDST_SPI0TX		23
+#define DRQDST_SPI1TX		24
+
+#if defined(CONFIG_ARCH_SUN8IW1) \
+	&& defined(CONFIG_ARCH_SUN9I)
+#define DRQDST_SPI2TX		25
+#define DRQDST_SPI3TX		26
+#endif
+
+#if defined(CONFIG_ARCH_SUN8IW1)
+#define DRQDST_NAND1		28
+#define DRQDST_MTC_ACC		29
+#define DRQDST_DIGITAL_MIC	30
+
+#elif defined(CONFIG_ARCH_SUN8IW6) \
+	|| defined(CONFIG_ARCH_SUN8IW7)
+
+#define DRQDST_DAUDIO_2_TX	27
+#define DRQDST_TDM_TX		28
+#define	DRQDST_CIR_TX		29
+#elif defined(CONFIG_ARCH_SUN50I)
+#define DRQDST_DAUDIO_2_TX	27
+#endif
+
+#endif /* CONFIG_ARCH_SUN8IW10 */
+
+#define sunxi_slave_id(d, s) (((d)<<16) | (s))
+#define GET_SRC_DRQ(x)	((x) & 0x000000ff)
+#define GET_DST_DRQ(x)	((x) & 0x00ff0000)
+
+/*
+ * The following DRQ type just for CPUs.
+ */
+#ifdef CONFIG_ARCH_SUN9I
+#define DRQSRC_R_DAUDIO_0_RX	1
+#define DRQSRC_R_UART_RX	2
+#define DRQSRC_R_CIR_RX		3
+#define DRQSRC_R_DAUDIO_1_RX	4
+#define DRQSRC_SPI3_RX		5
+
+#define DRQDST_R_DAUDIO_0_TX	1
+#define DRQDST_R_UART_TX	2
+#define DRQDST_R_CIR_TX		3
+#define DRQDST_R_DAUDIO_1_TX	4
+#define DRQDST_SPI3_TX		5
+#endif
+
+#define SUNXI_DMA_DRV	"sunxi_dmac"
+#define SUNXI_RDMA_DRV	"sunxi_rdmac"
+
+#define SUNXI_FILTER(name)	name##_filter_fn
+
+bool sunxi_rdma_filter_fn(struct dma_chan *chan, void *param);
+bool sunxi_dma_filter_fn(struct dma_chan *chan, void *param);
+
+struct sunxi_dma_info {
+	char name[16];
+	u32 port;
+	struct device *use_dev;
+};
+
+#endif /* __SUNXI_DMA_H__ */
diff --git a/include/linux/dma/sunxi/dma-sun50iw6.h b/include/linux/dma/sunxi/dma-sun50iw6.h
new file mode 100644
index 000000000..706e34985
--- /dev/null
+++ b/include/linux/dma/sunxi/dma-sun50iw6.h
@@ -0,0 +1,107 @@
+#ifndef __DMA_SUN50IW6__
+#define __DMA_SUN50IW6__
+
+/*
+ * The source DRQ type and port corresponding relation
+ *
+ */
+#define DRQSRC_SRAM		0
+#define DRQSRC_SDRAM		DRQSRC_SRAM
+#define DRQSRC_DRAM		1
+#define DRQSRC_SPDIFRX		2
+#define DRQSRC_OWARX		DRQSRC_SPDIFRX
+#define DRQSRC_DAUDIO_0_RX	3
+#define DRQSRC_DAI0_RX		DRQSRC_DAUDIO_0_RX
+#define DRQSRC_DAUDIO_1_RX	4
+#define DRQSRC_DAI1_RX		DRQSRC_DAUDIO_1_RX
+#define DRQSRC_DAUDIO_2_RX	5
+#define DRQSRC_DAI2_RX		DRQSRC_DAUDIO_2_RX
+#define DRQSRC_DAUDIO_3_RX	6
+#define DRQSRC_DAI3_RX		DRQSRC_DAUDIO_3_RX
+#define DRQSRC_DMIC		7
+/* #define DRQSRC_RESEVER	8 */
+#define DRQSRC_SS		9
+#define DRQSRC_CE_RX		DRQSRC_SS
+#define DRQSRC_NAND0		10
+/* #define DRQSRC_RESEVER	11 */
+/* #define DRQSRC_RESEVER	12 */
+/* #define DRQSRC_RESEVER	13 */
+#define DRQSRC_UART0RX		14
+#define DRQSRC_UART1RX		15
+#define DRQSRC_UART2RX		16
+#define DRQSRC_UART3RX		17
+/* #define DRQSRC_RESEVER	18 */
+/* #define DRQSRC_RESEVER	19 */
+/* #define DRQSRC_RESEVER	20 */
+/* #define DRQSRC_RESEVER	21 */
+#define DRQSRC_SPI0RX		22
+#define DRQSRC_SPI1RX		23
+/* #define DRQSRC_RESEVER	24 */
+/* #define DRQSRC_RESEVER	25 */
+/* #define DRQSRC_RESEVER	26 */
+/* #define DRQSRC_RESEVER	27 */
+/* #define DRQSRC_RESEVER	28 */
+/* #define DRQSRC_RESEVER	29 */
+#define DRQSRC_OTG_EP1		30
+#define DRQSRC_OTG_EP2		31
+#define DRQSRC_OTG_EP3		32
+#define DRQSRC_OTG_EP4		33
+#define DRQSRC_OTG_EP5		34
+
+/* Add by wolfgang to support Audio Hub */
+#define DRQSRC_AHUB0_RX		43
+#define DRQSRC_AHUB1_RX		44
+#define DRQSRC_AHUB2_RX		45
+
+/*
+ * The destination DRQ type and port corresponding relation
+ *
+ */
+#define DRQDST_SRAM		0
+#define DRQDST_SDRAM		DRQDST_SRAM
+#define DRQDST_DRAM		1
+#define DRQDST_SPDIFTX		2
+#define DRQDST_OWATX		DRQDST_SPDIFTX
+#define DRQDST_DAUDIO_0_TX	3
+#define DRQDST_DAI0_TX		DRQDST_DAUDIO_0_TX
+#define DRQDST_DAUDIO_1_TX	4
+#define DRQDST_DAI1_TX		DRQDST_DAUDIO_1_TX
+#define DRQDST_DAUDIO_2_TX	5
+#define DRQDST_DAI2_TX		DRQDST_DAUDIO_2_TX
+#define DRQDST_DAUDIO_3_TX	6
+#define DRQDST_DAI3_TX		DRQDST_DAUDIO_3_TX
+/* #define DRQDST_RESEVER	7 */
+/* #define DRQDST_RESEVER	8 */
+#define DRQDST_SS		9
+#define DRQDST_CE_TX		DRQDST_SS
+#define DRQDST_NAND0		10
+/* #define DRQDST_RESEVER	11 */
+/* #define DRQDST_RESEVER	12 */
+#define DRQDST_IR0TX		13
+#define DRQDST_UART0TX		14
+#define DRQDST_UART1TX 		15
+#define DRQDST_UART2TX		16
+#define DRQDST_UART3TX		17
+/* #define DRQDST_RESEVER	18 */
+/* #define DRQDST_RESEVER	19 */
+/* #define DRQDST_RESEVER	20 */
+/* #define DRQDST_RESEVER	21 */
+#define DRQDST_SPI0TX		22
+#define DRQDST_SPI1TX		23
+/* #define DRQDST_RESEVER	24 */
+/* #define DRQDST_RESEVER	25 */
+/* #define DRQDST_RESEVER	26 */
+/* #define DRQDST_RESEVER	27 */
+/* #define DRQDST_RESEVER	28 */
+/* #define DRQDST_RESEVER	29 */
+#define DRQDST_OTG_EP1		30
+#define DRQDST_OTG_EP2		31
+#define DRQDST_OTG_EP3		32
+#define DRQDST_OTG_EP4		33
+#define DRQDST_OTG_EP5		34
+
+/* Add by wolfgang to support Audio Hub */
+#define DRQDST_AHUB0_TX		43
+#define DRQDST_AHUB1_TX		44
+#define DRQDST_AHUB2_TX		45
+#endif /*__DMA_SUN50IW6__  */
diff --git a/include/sound/dmaengine_pcm.h b/include/sound/dmaengine_pcm.h
index 67be24459..e7b19b14f 100644
--- a/include/sound/dmaengine_pcm.h
+++ b/include/sound/dmaengine_pcm.h
@@ -102,6 +102,11 @@ void snd_dmaengine_pcm_set_config_from_dai_data(
  * makes sense if SND_DMAENGINE_PCM_FLAG_COMPAT is set as well.
  */
 #define SND_DMAENGINE_PCM_FLAG_NO_DT BIT(1)
+/*
+ * The platforms dmaengine driver does not support reporting the amount of
+ * bytes that are still left to transfer.
+ */
+#define SND_DMAENGINE_PCM_FLAG_NO_RESIDUE BIT(2)
 /*
  * The PCM is half duplex and the DMA channel is shared between capture and
  * playback.
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fee4b0ef5..ef2b92484 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -55,6 +55,14 @@ struct dentry *snd_soc_debugfs_root;
 EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
 #endif
 
+#ifdef dev_dbg
+#undef dev_dbg
+#define dev_dbg(dev, format, arg...) \
+({								\
+	printk("ROY:"format, ##arg);	\
+})
+#endif
+
 static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
@@ -1124,8 +1132,8 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	cpu_dai_component.dai_name = dai_link->cpu_dai_name;
 	rtd->cpu_dai = snd_soc_find_dai(&cpu_dai_component);
 	if (!rtd->cpu_dai) {
-		dev_err(card->dev, "ASoC: CPU DAI %s not registered\n",
-			dai_link->cpu_dai_name);
+		dev_err(card->dev, "ASoC: CPU DAI name: %s, dai: %s not registered\n",
+			dai_link->cpu_name, dai_link->cpu_dai_name);
 		goto _err_defer;
 	}
 	snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 22408bc2d..94e1fdeab 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -1,6 +1,24 @@
 menu "Allwinner SoC Audio support"
 	depends on ARCH_SUNXI || COMPILE_TEST
 
+config SND_SUNXI_SOC_AUDIO_DMA
+	bool
+	default y
+
+config AHUB_FREQ_REQ
+	bool
+	help
+		for AHUB design should use pll_auio * 4
+
+config SND_AC200_CODEC
+	tristate "X-Power AC200 Codec Support"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	select MFD_AC200
+	help
+	  Select Y or M to add support for the Codec embedded in the X-Power 
+		AC200 and affiliated SoCs.
+
 config SND_SUN4I_CODEC
 	tristate "Allwinner A10 Codec Support"
 	select SND_SOC_GENERIC_DMAENGINE_PCM
@@ -45,4 +63,41 @@ config SND_SUN4I_SPDIF
 	help
 	  Say Y or M to add support for the S/PDIF audio block in the Allwinner
 	  A10 and affiliated SoCs.
+
+config SND_SUNXI_SOC_SPDIF
+	tristate "ASoC support for spdif soundcard"
+	default n
+	help
+ 	  Say Y or M if you want to add the spdif soundcard include macheine plarform.
+
+config SND_SUNXI_SOC_DMIC
+	tristate "ASoC support for dmic."
+	help
+ 	  Say Y or M if you want to add the dmic interface.
+
+config SND_SUNXI_SOC_HDMIAUDIO
+	tristate "ASoC support for hdmiaudio."
+	help
+ 	  Say Y or M if you want to add the hdmi platform interface.
+
+config SND_SUNXI_SOC_AHUB
+	tristate "ASoC H6 support for audio hub support"
+	select REGMAP_MMIO
+	select AHUB_FREQ_REQ
+	select SND_SUNXI_SOC_AUDIO_DMA
+	help
+	  Say Y or M if you want to using ahub module.
+
+config SUNXI_AUDIO_DEBUG
+	bool "Support SUNXI AUDIO DEBUG"
+	depends on SND_SUNXI_SOC_AUDIO_DMA
+	help
+	  this is DEBUG function, add by LSH
+
+config SND_SUNXI_SOC_DAUDIO_MACHINE
+  tristate "ASoC H6 Support For Daudio"
+	select SND_SUNXI_SOC_AHUB
+	help
+    Say Y or M if you want to add the daudio machine interface.
+
 endmenu
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index 4a9ef6738..33755940d 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -4,3 +4,30 @@ obj-$(CONFIG_SND_SUN4I_I2S) += sun4i-i2s.o
 obj-$(CONFIG_SND_SUN4I_SPDIF) += sun4i-spdif.o
 obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
+
+#sun50i
+obj-$(CONFIG_SND_AC200_CODEC) += acx00-codec.o
+
+# # audio hub
+obj-$(CONFIG_SND_SUNXI_SOC_AHUB) += sunxi_dma.o
+obj-$(CONFIG_SND_SUNXI_SOC_AHUB) += sunxi_netlink.o
+obj-$(CONFIG_SND_SUNXI_SOC_AHUB) += sunxi_ahub.o
+obj-$(CONFIG_SND_SUNXI_SOC_AHUB) += sunxi_ahub_cpudai.o
+obj-$(CONFIG_SND_SUNXI_SOC_AHUB) += sunxi_ahub_daudio.o
+obj-$(CONFIG_SND_SUNXI_SOC_AHUB) += sunxi-sndahub.o
+
+# # ahub machine
+obj-$(CONFIG_SND_SUNXI_SOC_DAUDIO_MACHINE) += sunxi-snddaudio.o
+
+# # dmic
+obj-$(CONFIG_SND_SUNXI_SOC_DMIC) += sunxi_dmic.o
+obj-$(CONFIG_SND_SUNXI_SOC_DMIC) += sunxi-snddmic.o
+
+# # spdif
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += sunxi_spdif.o
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += sunxi-sndspdif.o
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += spdif-utils.o
+
+# # hdmi
+obj-$(CONFIG_SND_SUNXI_SOC_HDMIAUDIO) += sndhdmi.o
+obj-$(CONFIG_SND_SUNXI_SOC_HDMIAUDIO) += sunxi-sndhdmi.o
diff --git a/sound/soc/sunxi/acx00-codec.c b/sound/soc/sunxi/acx00-codec.c
new file mode 100644
index 000000000..0d81a7c15
--- /dev/null
+++ b/sound/soc/sunxi/acx00-codec.c
@@ -0,0 +1,1314 @@
+/*
+ * acx00.c  --  ACX00 ALSA Soc Audio Codec driver
+ *
+ * (C) Copyright 2010-2016 Allwinnertech Technology., Ltd.
+ *
+ * Author: Wolfgang Huang <huangjinhui@allwinner.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <linux/mfd/acx00-mfd.h>
+// #include <linux/sys_config.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/workqueue.h>
+
+#include "acx00-codec.h"
+
+
+#define ACX00_DEF_VOL		0x9F9F
+#undef ACX00_DAPM_LINEOUT
+
+struct acx00_priv {
+	struct acx00 *acx00;	/* parent mfd device struct */
+	struct snd_soc_codec *codec;
+	struct clk *clk;
+	unsigned int sample_rate;
+	unsigned int fmt;
+	unsigned int enable;
+	unsigned int spk_gpio;
+	bool spk_gpio_used;
+	struct mutex mutex;
+	struct delayed_work spk_work;
+	struct delayed_work resume_work;
+};
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+static const struct sample_rate sample_rate_conv[] = {
+	{44100, 7},
+	{48000, 8},
+	{8000, 0},
+	{32000, 6},
+	{22050, 4},
+	{24000, 5},
+	{16000, 3},
+	{11025, 1},
+	{12000, 2},
+	{192000, 10},
+	{96000, 9},
+};
+
+void __iomem *io_stat_addr;
+
+static const DECLARE_TLV_DB_SCALE(i2s_mixer_adc_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(i2s_mixer_dac_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(dac_mixer_adc_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(dac_mixer_dac_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(line_out_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(mic_out_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(phoneout_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(adc_input_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(lineout_tlv, -4800, 150, 1);
+static const unsigned int mic_boost_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 7, TLV_DB_SCALE_ITEM(2400, 300, 0),
+};
+
+static const struct snd_kcontrol_new acx00_codec_controls[] = {
+	SOC_DOUBLE_TLV("I2S Mixer ADC Volume", AC_I2S_MIXER_GAIN,
+			I2S_MIXERL_GAIN_ADC, I2S_MIXERR_GAIN_ADC,
+			0x1, 0, i2s_mixer_adc_tlv),
+	SOC_DOUBLE_TLV("I2S Mixer DAC Volume", AC_I2S_MIXER_GAIN,
+			I2S_MIXERR_GAIN_DAC, I2S_MIXERR_GAIN_DAC,
+			0x1, 0, i2s_mixer_dac_tlv),
+	SOC_DOUBLE_TLV("DAC Mixer ADC Volume", AC_DAC_MIXER_GAIN,
+			DAC_MIXERL_GAIN_ADC, DAC_MIXERR_GAIN_ADC,
+			0x1, 0, dac_mixer_adc_tlv),
+	SOC_DOUBLE_TLV("DAC Mxier DAC Volume", AC_DAC_MIXER_GAIN,
+			DAC_MIXERL_GAIN_DAC, DAC_MIXERR_GAIN_DAC,
+			0x1, 0, dac_mixer_dac_tlv),
+	SOC_SINGLE_TLV("Line Out Mixer Volume", AC_OUT_MIXER_CTL,
+			OUT_MIXER_LINE_VOL, 0x7, 0, line_out_tlv),
+	SOC_DOUBLE_TLV("MIC Out Mixer Volume", AC_OUT_MIXER_CTL,
+			OUT_MIXER_MIC1_VOL, OUT_MIXER_MIC2_VOL,
+			0x7, 0, mic_out_tlv),
+	SOC_SINGLE_TLV("ADC Input Volume", AC_ADC_MIC_CTL,
+			ADC_GAIN, 0x07, 0, adc_input_tlv),
+	SOC_SINGLE_TLV("LINEOUT Volume", AC_LINEOUT_CTL,
+			LINEOUT_VOL, 0x1f, 0, lineout_tlv),
+	SOC_SINGLE_TLV("MIC1 Boost Volume", AC_ADC_MIC_CTL,
+			MIC1_BOOST, 0x07, 0, mic_boost_tlv),
+	SOC_SINGLE_TLV("MIC2 Boost Volume", AC_ADC_MIC_CTL,
+			MIC2_BOOST, 0x07, 0, mic_boost_tlv),
+};
+
+/* Enable I2S & DAC clk, then enable the DAC digital part */
+static int acx00_playback_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);//w->codec;
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_I2S), (0x1<<SYS_CLK_I2S));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_I2S), (0x1<<MOD_RST_I2S));
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_DAC), (0x1<<SYS_CLK_DAC));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_DAC), (0x1<<MOD_RST_DAC));
+		snd_soc_update_bits(codec, AC_DAC_CTL,
+				(0x1<<DAC_CTL_DAC_EN), (0x1<<DAC_CTL_DAC_EN));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_I2S), (0x0<<SYS_CLK_I2S));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_I2S), (0x0<<MOD_RST_I2S));
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_DAC), (0x0<<SYS_CLK_DAC));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_DAC), (0x0<<MOD_RST_DAC));
+		snd_soc_update_bits(codec, AC_DAC_CTL,
+				(0x1<<DAC_CTL_DAC_EN), (0x0<<DAC_CTL_DAC_EN));
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/* Enable I2S & ADC clk, then enable the ADC digital part */
+static int acx00_capture_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);//w->codec;
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_I2S), (0x1<<SYS_CLK_I2S));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_I2S), (0x1<<MOD_RST_I2S));
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_ADC), (0x1<<SYS_CLK_ADC));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_ADC), (0x1<<MOD_RST_ADC));
+		snd_soc_update_bits(codec, AC_ADC_CTL,
+				(0x1<<ADC_EN), (0x1<<ADC_EN));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_I2S), (0x0<<SYS_CLK_I2S));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_I2S), (0x0<<MOD_RST_I2S));
+		snd_soc_update_bits(codec, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_ADC), (0x0<<SYS_CLK_ADC));
+		snd_soc_update_bits(codec, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_ADC), (0x0<<MOD_RST_ADC));
+		snd_soc_update_bits(codec, AC_ADC_CTL,
+				(0x1<<ADC_EN), (0x0<<ADC_EN));
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/*
+ * we used for three scene:
+ * 1. No external Spker & DAPM LINEOUT used, we just enable the LINEOUT in the
+ * ALSA codec probe(acx00_codec_probe) and resume, and we shutdown the LINEOUT
+ * in device shutdown or suspend.
+ * 2. No external Spker, but DAPM LINEOUT used, we just using the LINEOUT
+ * enable or disable throught the DAPM control.
+ * 3. External Spker & DAPM LINEOUT used, we just using the LINEOUT and
+ * External Spker control GPIO enable or disable through DAPM control.
+ */
+static unsigned int spk_delay = 100;
+module_param(spk_delay, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(spk_delay, "ACX00-Codec spk mute delay time");
+
+static void acx00_spk_enable(struct work_struct *work)
+{
+	struct acx00_priv *priv = container_of(work,
+			struct acx00_priv, spk_work.work);
+	gpio_set_value(priv->spk_gpio, 1);
+}
+
+static int acx00_lineout_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);//w->codec;
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		if (!priv->enable) {
+			snd_soc_update_bits(priv->codec, AC_LINEOUT_CTL,
+					(1<<LINEL_SRC_EN), (1<<LINEL_SRC_EN));
+			snd_soc_update_bits(priv->codec, AC_LINEOUT_CTL,
+					(1<<LINER_SRC_EN), (1<<LINER_SRC_EN));
+			msleep(100);
+			priv->enable = 1;
+		}
+#ifdef ACX00_DAPM_LINEOUT
+		snd_soc_update_bits(codec, AC_LINEOUT_CTL,
+				(1<<LINEOUT_EN), (1<<LINEOUT_EN));
+		mdelay(50);
+#endif
+		if (priv->spk_gpio_used) {
+			if (spk_delay == 0) {
+				gpio_set_value(priv->spk_gpio, 1);
+				/*
+				* time delay to wait spk pa work fine,
+				* general setting 50ms
+				*/
+				mdelay(50);
+			} else
+				schedule_delayed_work(&priv->spk_work,
+					msecs_to_jiffies(spk_delay));
+		}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		mdelay(50);
+		if (priv->spk_gpio_used) {
+			gpio_set_value(priv->spk_gpio, 0);
+			msleep(50);
+		}
+#ifdef ACX00_DAPM_LINEOUT
+		snd_soc_update_bits(codec, AC_LINEOUT_CTL,
+				(1<<LINEOUT_EN), (0<<LINEOUT_EN));
+#endif
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/* AC_I2S_MIXER_SRC : 0x2114 */
+static const struct snd_kcontrol_new i2sl_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACL Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERL_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCL Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERL_SRC_ADC, 1, 0),
+};
+
+static const struct snd_kcontrol_new i2sr_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACR Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERR_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCR Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERR_SRC_ADC, 1, 0),
+};
+
+/* AC_DAC_MIXER_SRC : 0x2202 */
+static const struct snd_kcontrol_new dacl_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACL Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERL_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCL Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERL_SRC_ADC, 1, 0),
+};
+
+static const struct snd_kcontrol_new dacr_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACR Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERR_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCR Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERR_SRC_ADC, 1, 0),
+};
+
+/* AC_OUT_MIXER_SRC : 0x2222 */
+static const struct snd_kcontrol_new left_output_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneN Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_PHN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINL Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_LINEL, 1, 0),
+	SOC_DAPM_SINGLE("DACL Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_DACL, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_DACR, 1, 0),
+};
+
+static const struct snd_kcontrol_new right_output_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneP Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_PHP, 1, 0),
+	SOC_DAPM_SINGLE("LINEINR Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_LINER, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_DACR, 1, 0),
+	SOC_DAPM_SINGLE("DACL Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_DACL, 1, 0),
+};
+
+/* AC_LINEOUT_CTL : 0x2224 */
+const char * const left_lineout_text[] = {
+	"Left OMixer", "LR OMixer",
+};
+
+static const struct soc_enum left_lineout_enum =
+	SOC_ENUM_SINGLE(AC_LINEOUT_CTL, LINEL_SRC,
+		ARRAY_SIZE(left_lineout_text), left_lineout_text);
+
+static const struct snd_kcontrol_new left_lineout_mux =
+	SOC_DAPM_ENUM("Left LINEOUT Mux", left_lineout_enum);
+
+const char * const right_lineout_text[] = {
+	"Right OMixer", "LR OMixer",
+};
+
+static const struct soc_enum right_lineout_enum =
+	SOC_ENUM_SINGLE(AC_LINEOUT_CTL, LINER_SRC,
+		ARRAY_SIZE(right_lineout_text), right_lineout_text);
+
+static const struct snd_kcontrol_new right_lineout_mux =
+	SOC_DAPM_ENUM("Right LINEOUT Mux", right_lineout_enum);
+
+/* AC_ADC_MIXER_SRC : 0x2322 */
+static const struct snd_kcontrol_new left_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneN Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_PHN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINL Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_LINEL, 1, 0),
+	SOC_DAPM_SINGLE("OMixerL Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIXL, 1, 0),
+	SOC_DAPM_SINGLE("OMixerR Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIXR, 1, 0),
+};
+
+static const struct snd_kcontrol_new right_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneP Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_PHP, 1, 0),
+	SOC_DAPM_SINGLE("LINEINR Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_LINER, 1, 0),
+	SOC_DAPM_SINGLE("OMixerR Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIXR, 1, 0),
+	SOC_DAPM_SINGLE("OMixerL Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIXL, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget acx00_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Playback", 0, AC_DAC_CTL,
+			OUT_MIXER_DACL_EN, 0,
+			acx00_playback_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Playback", 0,
+			AC_DAC_CTL, OUT_MIXER_DACR_EN, 0,
+			acx00_playback_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADCL", "Capture", 0,
+			AC_ADC_MIC_CTL, ADCL_EN, 0,
+			acx00_capture_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("ADCR", "Capture", 0,
+			AC_ADC_MIC_CTL, ADCR_EN, 0,
+			acx00_capture_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER("Left Output Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_LMIX_EN, 0,
+			left_output_mixer, ARRAY_SIZE(left_output_mixer)),
+
+	SND_SOC_DAPM_MIXER("Right Output Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_RMIX_EN, 0, right_output_mixer,
+			ARRAY_SIZE(right_output_mixer)),
+
+	SND_SOC_DAPM_MIXER("Left Input Mixer", SND_SOC_NOPM, 0, 0,
+			left_input_mixer, ARRAY_SIZE(left_input_mixer)),
+	SND_SOC_DAPM_MIXER("Right Input Mixer", SND_SOC_NOPM, 0, 0,
+			right_input_mixer, ARRAY_SIZE(right_input_mixer)),
+
+	SND_SOC_DAPM_MIXER("Left DAC Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_DACL_EN, 0, dacl_mixer_src,
+			ARRAY_SIZE(dacl_mixer_src)),
+	SND_SOC_DAPM_MIXER("Right DAC Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_DACR_EN, 0, dacr_mixer_src,
+			ARRAY_SIZE(dacr_mixer_src)),
+
+	SND_SOC_DAPM_MIXER("Left I2S Mixer", SND_SOC_NOPM,
+			0, 0, i2sl_mixer_src, ARRAY_SIZE(i2sl_mixer_src)),
+	SND_SOC_DAPM_MIXER("Right I2S Mixer", SND_SOC_NOPM,
+			0, 0, i2sr_mixer_src, ARRAY_SIZE(i2sr_mixer_src)),
+
+	SND_SOC_DAPM_MUX("Left LINEOUT Mux", SND_SOC_NOPM,
+			0, 0, &left_lineout_mux),
+	SND_SOC_DAPM_MUX("Right LINEOUT Mux", SND_SOC_NOPM,
+			0, 0, &right_lineout_mux),
+
+	SND_SOC_DAPM_PGA("MIC1 PGA", AC_ADC_MIC_CTL,
+			MIC1_GAIN_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC2 PGA", AC_ADC_MIC_CTL,
+			MIC2_GAIN_EN, 0, NULL, 0),
+
+	SND_SOC_DAPM_MICBIAS("MIC Bias", AC_MICBIAS_CTL,
+			MMBIAS_EN, 0),
+
+	/* PHONEIN & PHONEOUT not enable in pin assign */
+	SND_SOC_DAPM_INPUT("PHONEINP"),
+	SND_SOC_DAPM_INPUT("PHONEINN"),
+	SND_SOC_DAPM_INPUT("PHONEINPN"),
+
+	/* endpoint define */
+	SND_SOC_DAPM_LINE("LINEIN", NULL),
+	SND_SOC_DAPM_LINE("LINEOUT", acx00_lineout_event),
+	SND_SOC_DAPM_MIC("MIC1", NULL),
+	SND_SOC_DAPM_MIC("MIC2", NULL),
+};
+
+static const struct snd_soc_dapm_route acx00_codec_dapm_routes[] = {
+	{"Left Output Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Left Output Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Left Output Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Left Output Mixer", "PhoneN Switch", "PHONEINN"},
+	{"Left Output Mixer", "LINEINL Switch", "LINEIN"},
+	{"Left Output Mixer", "DACR Switch", "Right DAC Mixer"},
+	{"Left Output Mixer", "DACL Switch", "Left DAC Mixer"},
+
+	{"Right Output Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Right Output Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Right Output Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Right Output Mixer", "PhoneP Switch", "PHONEINP"},
+	{"Right Output Mixer", "LINEINR Switch", "LINEIN"},
+	{"Right Output Mixer", "DACR Switch", "Right DAC Mixer"},
+	{"Right Output Mixer", "DACL Switch", "Left DAC Mixer"},
+
+	{"Left LINEOUT Mux", NULL, "Left Output Mixer"},
+	{"Left LINEOUT Mux", "LR OMixer", "Right Output Mixer"},
+	{"Right LINEOUT Mux", NULL, "Right Output Mixer"},
+	{"Right LINEOUT Mux", "LR OMixer", "Left Output Mixer"},
+
+	{"Left Input Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Left Input Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Left Input Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Left Input Mixer", "PhoneN Switch", "PHONEINN"},
+	{"Left Input Mixer", "LINEINL Switch", "LINEIN"},
+	{"Left Input Mixer", "OMixerL Switch", "Left Output Mixer"},
+	{"Left Input Mixer", "OMixerR Switch", "Right Output Mixer"},
+
+	{"Right Input Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Right Input Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Right Input Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Right Input Mixer", "PhoneP Switch", "PHONEINP"},
+	{"Right Input Mixer", "LINEINR Switch", "LINEIN"},
+	{"Right Input Mixer", "OMixerR Switch", "Right Output Mixer"},
+	{"Right Input Mixer", "OMixerL Switch", "Left Output Mixer"},
+
+	{"Left I2S Mixer", "I2SDACL Switch", "DACL"},
+	{"Left I2S Mixer", "ADCL Switch", "Left Input Mixer"},
+
+	{"Right I2S Mixer", "I2SDACR Switch", "DACR"},
+	{"Right I2S Mixer", "ADCR Switch", "Right Input Mixer"},
+
+	{"Left DAC Mixer", "I2SDACL Switch", "DACL"},
+	{"Left DAC Mixer", "ADCL Switch", "Left Input Mixer"},
+
+	{"Right DAC Mixer", "I2SDACR Switch", "DACR"},
+	{"Right DAC Mixer", "ADCR Switch", "Right Input Mixer"},
+
+	{"ADCL", NULL, "Left I2S Mixer"},
+	{"ADCR", NULL, "Right I2S Mixer"},
+
+	{"LINEOUT", NULL, "Left LINEOUT Mux"},
+	{"LINEOUT", NULL, "Right LINEOUT Mux"},
+
+	{"MIC Bias", NULL, "MIC1"},
+	{"MIC Bias", NULL, "MIC2"},
+	{"MIC1 PGA", NULL, "MIC Bias"},
+	{"MIC2 PGA", NULL, "MIC Bias"},
+};
+
+static void acx00_codec_txctrl_enable(struct snd_soc_codec *codec,
+					int enable)
+{
+	pr_debug("Enter %s, enable %d\n", __func__, enable);
+	if (enable) {
+		snd_soc_update_bits(codec, AC_I2S_CTL,
+					(1<<I2S_RX_EN), (1<<I2S_RX_EN));
+	} else {
+		snd_soc_update_bits(codec, AC_I2S_CTL,
+					(1<<I2S_RX_EN), (0<<I2S_RX_EN));
+	}
+	pr_debug("End %s, enable %d\n", __func__, enable);
+}
+
+static void acx00_codec_rxctrl_enable(struct snd_soc_codec *codec,
+					int enable)
+{
+	pr_debug("Enter %s, enable %d\n", __func__, enable);
+	if (enable) {
+		snd_soc_update_bits(codec, AC_I2S_CTL,
+					(1<<I2S_TX_EN), (1<<I2S_TX_EN));
+	} else {
+		snd_soc_update_bits(codec, AC_I2S_CTL,
+					(1<<I2S_TX_EN), (0<<I2S_TX_EN));
+	}
+	pr_debug("End %s, enable %d\n", __func__, enable);
+}
+
+static void acx00_codec_init(struct snd_soc_codec *codec)
+{
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	/* acx00_codec sysctl init */
+	acx00_reg_write(priv->acx00, 0x0010, 0x03);
+	acx00_reg_write(priv->acx00, 0x0012, 0x01);
+
+	/* enable the output & global enable bit */
+	snd_soc_update_bits(codec, AC_I2S_CTL,
+			(1<<I2S_SDO0_EN), (1<<I2S_SDO0_EN));
+	snd_soc_update_bits(codec, AC_I2S_CTL, (1<<I2S_GEN), (1<<I2S_GEN));
+
+	/* Default setting slot width as 32 bit for I2S */
+	snd_soc_update_bits(codec, AC_I2S_FMT0,
+			(7<<I2S_FMT_SLOT_WIDTH), (7<<I2S_FMT_SLOT_WIDTH));
+
+	/* default setting 0xA0A0 for ADC & DAC Volume */
+	snd_soc_write(codec, AC_I2S_DAC_VOL, ACX00_DEF_VOL);
+	snd_soc_write(codec, AC_I2S_ADC_VOL, ACX00_DEF_VOL);
+
+	/* Enable HPF for high pass filter */
+	snd_soc_update_bits(codec, AC_DAC_CTL,
+			(1<<DAC_CTL_HPF_EN), (1<<DAC_CTL_HPF_EN));
+
+	/* LINEOUT ANTI POP & Click noise */
+	snd_soc_update_bits(codec, AC_LINEOUT_CTL,
+			(0x7<<LINE_ANTI_TIME), (0x3<<LINE_ANTI_TIME));
+	snd_soc_update_bits(codec, AC_LINEOUT_CTL,
+			(0x3<<LINE_SLOPE_SEL), (0x3<<LINE_SLOPE_SEL));
+
+	/* enable & setting adc convert delay time */
+	snd_soc_update_bits(codec, AC_ADC_CTL, (0x3<<ADC_DELAY_TIME),
+			(0x3<<ADC_DELAY_TIME));
+	snd_soc_update_bits(codec, AC_ADC_CTL, (1<<ADC_DELAY_EN),
+			(1<<ADC_DELAY_EN));
+
+
+	if (priv->spk_gpio_used) {
+		snd_soc_update_bits(priv->codec, AC_LINEOUT_CTL,
+					(1<<LINEL_SRC_EN), (1<<LINEL_SRC_EN));
+		snd_soc_update_bits(priv->codec, AC_LINEOUT_CTL,
+					(1<<LINER_SRC_EN), (1<<LINER_SRC_EN));
+		priv->enable = 1;
+	}
+#ifndef ACX00_DAPM_LINEOUT
+	snd_soc_update_bits(codec, AC_LINEOUT_CTL, (1<<LINEOUT_EN),
+			(1<<LINEOUT_EN));
+#endif
+}
+
+static int acx00_codec_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	int i;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+			(7<<I2S_FMT_SAMPLE), (3<<I2S_FMT_SAMPLE));
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+			(7<<I2S_FMT_SAMPLE), (5<<I2S_FMT_SAMPLE));
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+			(7<<I2S_FMT_SAMPLE), (7<<I2S_FMT_SAMPLE));
+		break;
+	default:
+		dev_err(codec->dev, "unrecognized format support\n");
+		break;
+	}
+	for (i = 0; i < ARRAY_SIZE(sample_rate_conv); i++) {
+		if (sample_rate_conv[i].samplerate == params_rate(params)) {
+			snd_soc_update_bits(codec, AC_SYS_SR_CTL,
+				(SYS_SR_MASK<<SYS_SR_BIT),
+				(sample_rate_conv[i].rate_bit<<SYS_SR_BIT));
+		}
+	}
+
+	return 0;
+}
+
+static int acx00_codec_dai_set_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int acx00_codec_dai_set_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct acx00_priv *priv = snd_soc_dai_get_drvdata(codec_dai);
+	struct snd_soc_codec *codec = priv->codec;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	/* codec clk & FRM master */
+	case SND_SOC_DAIFMT_CBM_CFM:
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x1<<I2S_BCLK_OUT), (0x1<<I2S_BCLK_OUT));
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x1<<I2S_LRCK_OUT), (0x1<<I2S_LRCK_OUT));
+		break;
+	/* codec clk & FRM slave */
+	case SND_SOC_DAIFMT_CBS_CFS:
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x1<<I2S_BCLK_OUT), 0x0<<I2S_BCLK_OUT);
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x1<<I2S_LRCK_OUT), 0x0<<I2S_LRCK_OUT);
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x1F<<I2S_LRCK_PERIOD));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x1<<I2S_FMT_MODE));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x1<<I2S_FMT_TX_OFFSET));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x1<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x1F<<I2S_LRCK_PERIOD));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x2<<I2S_FMT_MODE));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_TX_OFFSET));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x1F<<I2S_LRCK_PERIOD));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x1<<I2S_FMT_MODE));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_TX_OFFSET));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x0<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x3F<<I2S_LRCK_PERIOD));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x0<<I2S_FMT_MODE));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x1<<I2S_FMT_TX_OFFSET));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x1<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		snd_soc_update_bits(codec, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x3F<<I2S_LRCK_PERIOD));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x0<<I2S_FMT_MODE));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_TX_OFFSET));
+		snd_soc_update_bits(codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x0<<I2S_FMT_RX_OFFSET));
+		break;
+	default:
+		dev_err(codec->dev, "format setting failed\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x0<<I2S_FMT_BCLK_POLAR));
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x0<<I2S_FMT_LRCK_POLAR));
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x0<<I2S_FMT_BCLK_POLAR));
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x1<<I2S_FMT_LRCK_POLAR));
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x1<<I2S_FMT_BCLK_POLAR));
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x0<<I2S_FMT_LRCK_POLAR));
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x1<<I2S_FMT_BCLK_POLAR));
+		snd_soc_update_bits(codec, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x1<<I2S_FMT_LRCK_POLAR));
+		break;
+	default:
+		dev_err(codec->dev, "invert clk setting failed\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int acx00_codec_dai_set_clkdiv(struct snd_soc_dai *codec_dai,
+		int clk_id, int clk_div)
+{
+	struct acx00_priv *priv = snd_soc_dai_get_drvdata(codec_dai);
+	struct snd_soc_codec *codec = priv->codec;
+	unsigned int bclk_div;
+	/*
+	 * when PCM mode, setting as 64fs, when I2S mode as 32fs,
+	 * then two channel, then just as 64fs
+	 */
+	unsigned int div_ratio = clk_div / 64;
+
+	switch (div_ratio) {
+	case 1:
+		bclk_div = I2S_BCLK_DIV_1;
+		break;
+	case 2:
+		bclk_div = I2S_BCLK_DIV_2;
+		break;
+	case 4:
+		bclk_div = I2S_BCLK_DIV_3;
+		break;
+	case 6:
+		bclk_div = I2S_BCLK_DIV_4;
+		break;
+	case 8:
+		bclk_div = I2S_BCLK_DIV_5;
+		break;
+	case 12:
+		bclk_div = I2S_BCLK_DIV_6;
+		break;
+	case 16:
+		bclk_div = I2S_BCLK_DIV_7;
+		break;
+	case 24:
+		bclk_div = I2S_BCLK_DIV_8;
+		break;
+	case 32:
+		bclk_div = I2S_BCLK_DIV_9;
+		break;
+	case 48:
+		bclk_div = I2S_BCLK_DIV_10;
+		break;
+	case 64:
+		bclk_div = I2S_BCLK_DIV_11;
+		break;
+	case 96:
+		bclk_div = I2S_BCLK_DIV_12;
+		break;
+	case 128:
+		bclk_div = I2S_BCLK_DIV_13;
+		break;
+	case 176:
+		bclk_div = I2S_BCLK_DIV_14;
+		break;
+	case 192:
+		bclk_div = I2S_BCLK_DIV_15;
+		break;
+	default:
+		dev_err(codec->dev, "setting blck div failed\n");
+		break;
+	}
+
+	snd_soc_update_bits(codec, AC_I2S_CLK,
+			(I2S_BCLK_DIV_MASK<<I2S_BLCK_DIV),
+			(bclk_div<<I2S_BLCK_DIV));
+	return 0;
+}
+
+static int acx00_codec_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *codec_dai)
+{
+	return 0;
+}
+
+static bool acx00_loop_en;
+module_param(acx00_loop_en, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(acx00_loop_en, "ACX00-Codec audio loopback debug(Y=enable, N=disable)");
+/*
+static int acx00_codec_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *codec_dai)
+{
+	return 0;
+}
+*/
+static int acx00_codec_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *codec_dai)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (acx00_loop_en)
+			snd_soc_update_bits(codec_dai->codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_LOOP),
+				(0x1<<I2S_FMT_LOOP));
+		else
+			snd_soc_update_bits(codec_dai->codec, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_LOOP),
+				(0x0<<I2S_FMT_LOOP));
+		acx00_codec_txctrl_enable(codec_dai->codec, 1);
+	}
+	else
+		acx00_codec_rxctrl_enable(codec_dai->codec, 1);
+	return 0;
+}
+
+static int acx00_codec_digital_mute(struct snd_soc_dai *codec_dai,
+				int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+
+	if (mute)
+		snd_soc_write(codec, AC_I2S_DAC_VOL, 0);
+	else
+		snd_soc_write(codec, AC_I2S_DAC_VOL, ACX00_DEF_VOL);
+	return 0;
+}
+
+static void acx00_codec_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		acx00_codec_txctrl_enable(codec, 0);
+	else
+		acx00_codec_rxctrl_enable(codec, 0);
+}
+
+static const struct snd_soc_dai_ops acx00_codec_dai_ops = {
+	.hw_params	= acx00_codec_hw_params,
+	.shutdown	= acx00_codec_shutdown,
+	.digital_mute	= acx00_codec_digital_mute,
+	.set_sysclk	= acx00_codec_dai_set_sysclk,
+	.set_fmt	= acx00_codec_dai_set_fmt,
+	.set_clkdiv	= acx00_codec_dai_set_clkdiv,
+	.startup	= acx00_codec_startup,
+	/*.trigger	= acx00_codec_trigger,*/
+	.prepare	= acx00_codec_prepare,
+};
+
+static struct snd_soc_dai_driver acx00_codec_dai[] = {
+	{
+		.name = "acx00-dai",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &acx00_codec_dai_ops,
+	},
+};
+
+static void acx00_codec_resume_work(struct work_struct *work)
+{
+	struct acx00_priv *priv = container_of(work,
+			struct acx00_priv, resume_work.work);
+
+	acx00_codec_init(priv->codec);
+}
+
+static int acx00_codec_probe(struct snd_soc_codec *codec)
+{
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	mutex_init(&priv->mutex);
+
+	priv->codec = codec;
+
+	/* using late_initcall to wait 120ms acx00-core to make chip reset */
+	acx00_codec_init(codec);
+	INIT_DELAYED_WORK(&priv->spk_work, acx00_spk_enable);
+	INIT_DELAYED_WORK(&priv->resume_work, acx00_codec_resume_work);
+	return 0;
+}
+
+static int acx00_codec_remove(struct snd_soc_codec *codec)
+{
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	cancel_delayed_work_sync(&priv->spk_work);
+	cancel_delayed_work_sync(&priv->resume_work);
+	return 0;
+}
+
+static unsigned int acx00_codec_read(struct snd_soc_codec *codec,
+					unsigned int reg)
+{
+	unsigned int data;
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	/* Device I/O API */
+	data = acx00_reg_read(priv->acx00, reg);
+	return data;
+}
+
+static int acx00_codec_write(struct snd_soc_codec *codec,
+			unsigned int reg, unsigned int value)
+{
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	return acx00_reg_write(priv->acx00, reg, value);
+}
+
+static int sunxi_gpio_iodisable(u32 gpio)
+{
+	/* FIXME: ROY */
+	// char pin_name[8];
+	// u32 config, ret;
+	// sunxi_gpio_to_name(gpio, pin_name);
+	// config = 7 << 16;
+	// ret = pin_config_set(SUNXI_PINCTRL, pin_name, config);
+	// return ret;
+	return 0;
+}
+
+static int acx00_codec_suspend(struct snd_soc_codec *codec)
+{
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	pr_debug("Enter %s\n", __func__);
+
+	clk_disable_unprepare(priv->clk);
+
+	/* PA_CTRL first setting low state, then make it iodisabled */
+	if (priv->spk_gpio_used) {
+		sunxi_gpio_iodisable(priv->spk_gpio);
+		msleep(30);
+	}
+
+	/*
+	 * when codec suspend, then the register reset, if auto reset produce
+	 * Pop & Click noise, then we should cut down the LINEOUT in this town.
+	 */
+	if (priv->enable) {
+		snd_soc_update_bits(codec, AC_LINEOUT_CTL,
+				(1<<LINEOUT_EN), (0<<LINEOUT_EN));
+		snd_soc_update_bits(priv->codec, AC_LINEOUT_CTL,
+				(1<<LINEL_SRC_EN), (0<<LINEL_SRC_EN));
+		snd_soc_update_bits(priv->codec, AC_LINEOUT_CTL,
+				(1<<LINER_SRC_EN), (0<<LINER_SRC_EN));
+		priv->enable = 0;
+	}
+
+	pr_debug("Exit %s\n", __func__);
+
+	return 0;
+}
+
+static int acx00_codec_resume(struct snd_soc_codec *codec)
+{
+	struct acx00_priv *priv = snd_soc_codec_get_drvdata(codec);
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (clk_prepare_enable(priv->clk)) {
+		dev_err(codec->dev, "codec resume clk failed\n");
+		return -EBUSY;
+	}
+
+	schedule_delayed_work(&priv->resume_work, msecs_to_jiffies(300));
+
+	if (priv->spk_gpio_used) {
+		gpio_direction_output(priv->spk_gpio, 1);
+		gpio_set_value(priv->spk_gpio, 0);
+	}
+
+	pr_debug("Exit %s\n", __func__);
+
+	return 0;
+}
+
+
+static int acx00_codec_set_bias_level(struct snd_soc_codec *codec,
+		enum snd_soc_bias_level level)
+{
+	snd_soc_codec_get_dapm(codec)->bias_level = level;
+	return 0;
+}
+
+struct label {
+	const char *name;
+	int value;
+};
+
+#define LABEL(constant) { #constant, constant }
+#define LABEL_END { NULL, -1 }
+
+static struct label reg_labels[] = {
+	LABEL(AC_SYS_CLK_CTL),
+	LABEL(AC_SYS_MOD_RST),
+	LABEL(AC_SYS_SR_CTL),
+	LABEL(AC_I2S_CTL),
+	LABEL(AC_I2S_CLK),
+	LABEL(AC_I2S_FMT0),
+	LABEL(AC_I2S_FMT1),
+	LABEL(AC_I2S_MIXER_SRC),
+	LABEL(AC_I2S_MIXER_GAIN),
+	LABEL(AC_I2S_DAC_VOL),
+	LABEL(AC_I2S_ADC_VOL),
+	LABEL(AC_DAC_CTL),
+	LABEL(AC_DAC_MIXER_SRC),
+	LABEL(AC_DAC_MIXER_GAIN),
+	LABEL(AC_OUT_MIXER_CTL),
+	LABEL(AC_OUT_MIXER_SRC),
+	LABEL(AC_LINEOUT_CTL),
+	LABEL(AC_ADC_CTL),
+	LABEL(AC_MICBIAS_CTL),
+	LABEL(AC_ADC_MIC_CTL),
+	LABEL(AC_ADC_MIXER_SRC),
+	LABEL(AC_BIAS_CTL),
+	LABEL(AC_ANALOG_PROF_CTL),
+	LABEL_END,
+};
+
+static ssize_t show_audio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct acx00_priv *priv = dev_get_drvdata(dev);
+	int count = 0, i = 0;
+	unsigned int reg_val;
+
+	count += sprintf(buf, "dump audio reg:\n");
+
+	while (reg_labels[i].name != NULL) {
+		reg_val = acx00_reg_read(priv->acx00, reg_labels[i].value);
+		count += sprintf(buf + count, "%s 0x%x: 0x%04x\n",
+		reg_labels[i].name, (reg_labels[i].value), reg_val);
+		i++;
+	}
+
+	return count;
+}
+
+/*
+ * param 1: 0 read;1 write
+ * param 2: 1 digital reg; 2 analog reg
+ * param 3: reg value;
+ * param 4: write value;
+ * read:
+ * echo 0,1,0x00> audio_reg
+ * echo 0,2,0x00> audio_reg
+ * write:
+ * echo 1,1,0x00,0xa > audio_reg
+ * echo 1,2,0x00,0xff > audio_reg
+*/
+static ssize_t store_audio_reg(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int input_reg_val = 0;
+	int input_reg_group = 0;
+	int input_reg_offset = 0;
+	struct acx00_priv *priv = dev_get_drvdata(dev);
+
+	ret = sscanf(buf, "%d,%d,0x%x,0x%x", &rw_flag, &input_reg_group,
+			&input_reg_offset, &input_reg_val);
+	dev_info(dev, "ret:%d, reg_group:%d, reg_offset:%d, reg_val:0x%x\n",
+			ret, input_reg_group, input_reg_offset, input_reg_val);
+
+	if (input_reg_group != 1) {
+		pr_err("not exist reg group\n");
+		ret = count;
+		goto out;
+	}
+	if (!(rw_flag == 1 || rw_flag == 0)) {
+		pr_err("not rw_flag\n");
+		ret = count;
+		goto out;
+	}
+
+	if (rw_flag) {
+		acx00_reg_write(priv->acx00, input_reg_offset, input_reg_val);
+	} else {
+		input_reg_val = acx00_reg_read(priv->acx00, input_reg_offset);
+		dev_info(dev, "\n\n Reg[0x%x] : 0x%04x\n\n",
+				input_reg_offset, input_reg_val);
+	}
+	ret = count;
+
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(audio_reg, 0644, show_audio_reg, store_audio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_audio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group audio_debug_attr_group = {
+	.name   = "audio_reg_debug",
+	.attrs  = audio_debug_attrs,
+};
+
+static struct snd_soc_codec_driver soc_codec_driver_acx00 = {
+	.probe			= acx00_codec_probe,
+	.remove			= acx00_codec_remove,
+	.suspend		= acx00_codec_suspend,
+	.resume			= acx00_codec_resume,
+	.read			= acx00_codec_read,
+	.write			= acx00_codec_write,
+	.ignore_pmdown_time	= 1,
+	.set_bias_level		= acx00_codec_set_bias_level,
+	.component_driver = 
+	{
+		.dapm_widgets		= acx00_codec_dapm_widgets,
+		.num_dapm_widgets	= ARRAY_SIZE(acx00_codec_dapm_widgets),
+		.controls		= acx00_codec_controls,
+		.num_controls		= ARRAY_SIZE(acx00_codec_controls),
+		.dapm_routes		= acx00_codec_dapm_routes,
+		.num_dapm_routes	= ARRAY_SIZE(acx00_codec_dapm_routes),
+	},
+};
+
+/* through acx00 is part of mfd devices, after the mfd */
+static int acx00_codec_dev_probe(struct platform_device *pdev)
+{
+	struct acx00_priv *priv;
+	int ret;
+	struct device_node *np = of_find_compatible_node(NULL, NULL,
+				"allwinner,ac200_codec");
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct acx00_priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "acx00 codec priv mem alloc failed\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, priv);
+	priv->acx00 = dev_get_drvdata(pdev->dev.parent);
+
+	if (np) {
+		ret = of_get_named_gpio(np, "gpio-spk", 0);
+		if (ret >= 0) {
+			priv->spk_gpio_used = 1;
+			priv->spk_gpio = ret;
+			if (!gpio_is_valid(priv->spk_gpio)) {
+				dev_err(&pdev->dev, "gpio-spk is valid\n");
+				ret = -EINVAL;
+				goto err_devm_kfree;
+			} else {
+				ret = devm_gpio_request(&pdev->dev,
+				priv->spk_gpio, "SPK");
+				if (ret) {
+					dev_err(&pdev->dev,
+						"failed request gpio-spk\n");
+					ret = -EBUSY;
+					goto err_devm_kfree;
+				} else {
+					gpio_direction_output(priv->spk_gpio,
+								1);
+					gpio_set_value(priv->spk_gpio, 0);
+				}
+			}
+		} else {
+			priv->spk_gpio_used = 0;
+		}
+	}
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_driver_acx00,
+			acx00_codec_dai, ARRAY_SIZE(acx00_codec_dai));
+	if (ret < 0)
+		dev_err(&pdev->dev, "Failed register acx00: %d\n", ret);
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	if (ret)
+		dev_warn(&pdev->dev, "failed to create attr group\n");
+
+	pr_info("ac200 codec probe ok\n");
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, priv);
+	return ret;
+}
+
+/* Mark this space to clear the LINEOUT & gpio */
+static void acx00_codec_dev_shutdown(struct platform_device *pdev)
+{
+	struct acx00_priv *priv = platform_get_drvdata(pdev);
+
+	if (priv->spk_gpio_used)
+		gpio_set_value(priv->spk_gpio, 0);
+}
+
+static int acx00_codec_dev_remove(struct platform_device *pdev)
+{
+	struct acx00_priv *priv = platform_get_drvdata(pdev);
+
+#ifndef ACX00_DAPM_LINEOUT
+	snd_soc_update_bits(priv->codec, AC_LINEOUT_CTL,
+			(1<<LINEOUT_EN), (0<<LINEOUT_EN));
+#endif
+	snd_soc_unregister_codec(&pdev->dev);
+	clk_disable_unprepare(priv->clk);
+	devm_kfree(&pdev->dev, priv);
+	return 0;
+}
+
+static struct platform_driver acx00_codec_driver = {
+	.driver = {
+		.name = "acx00-codec",
+		.owner = THIS_MODULE,
+	},
+	.probe = acx00_codec_dev_probe,
+	.remove = acx00_codec_dev_remove,
+	.shutdown = acx00_codec_dev_shutdown,
+};
+
+static int __init acx00_codec_driver_init(void)
+{
+	return platform_driver_register(&acx00_codec_driver);
+}
+
+static void __exit acx00_codec_driver_exit(void)
+{
+	platform_driver_unregister(&acx00_codec_driver);
+}
+
+late_initcall(acx00_codec_driver_init);
+module_exit(acx00_codec_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SUNXI ASoC ACX00 Codec Driver");
+MODULE_AUTHOR("wolfgang huang");
+MODULE_ALIAS("platform:acx00-codec");
diff --git a/sound/soc/sunxi/acx00-codec.h b/sound/soc/sunxi/acx00-codec.h
new file mode 100644
index 000000000..10bf05d0b
--- /dev/null
+++ b/sound/soc/sunxi/acx00-codec.h
@@ -0,0 +1,355 @@
+/*
+ * sound\soc\codecs\acx00.h
+ * (C) Copyright 2012-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang Huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __ACX00_H_
+#define __ACX00_H_
+
+/* ACX00 register offset list */
+#define AC_SYS_CLK_CTL		0x2000
+#define AC_SYS_MOD_RST		0x2002
+#define AC_SYS_SR_CTL		0x2004
+/* Left blank */
+#define AC_I2S_CTL		0x2100
+#define AC_I2S_CLK		0x2102
+#define AC_I2S_FMT0		0x2104
+/* Left blank */
+#define AC_I2S_FMT1		0x2108
+/* Left blank */
+#define AC_I2S_MIXER_SRC	0x2114
+#define AC_I2S_MIXER_GAIN	0x2116
+#define AC_I2S_DAC_VOL		0x2118
+#define AC_I2S_ADC_VOL		0x211A
+/* Left blank */
+#define AC_DAC_CTL		0x2200
+#define AC_DAC_MIXER_SRC	0x2202
+#define AC_DAC_MIXER_GAIN	0x2204
+/* Left blank */
+#define AC_OUT_MIXER_CTL	0x2220
+#define AC_OUT_MIXER_SRC	0x2222
+#define AC_LINEOUT_CTL		0x2224
+/* Left blank */
+#define AC_ADC_CTL		0x2300
+/* Left blank */
+#define AC_MICBIAS_CTL		0x2310
+/* Left blank */
+#define AC_ADC_MIC_CTL		0x2320
+#define AC_ADC_MIXER_SRC	0x2322
+/* Left blank */
+#define AC_BIAS_CTL		0x232A
+#define AC_ANALOG_PROF_CTL	0x232C
+/* Left blank */
+#define AC_ADC_DAPL_CTRL	0x2500
+#define AC_ADC_DAPR_CTRL	0x2502
+#define AC_ADC_DAPLSTA		0x2504
+#define AC_ADC_DAPRSTA		0x2506
+#define AC_ADC_DAP_LTL		0x2508
+#define AC_ADC_DAP_RTL		0x250A
+#define AC_ADC_DAP_LHAC		0x250C
+#define AC_ADC_DAP_LLAC		0x250E
+#define AC_ADC_DAP_RHAC		0x2510
+#define AC_ADC_DAP_RLAC		0x2512
+#define AC_ADC_DAP_LDT		0x2514
+#define AC_ADC_DAP_LAT		0x2516
+#define AC_ADC_DAP_RDT		0x2518
+#define AC_ADC_DAP_RAT		0x251A
+#define AC_ADC_DAP_NTH		0x251C
+#define AC_ADC_DAP_LHNAC	0x251E
+#define AC_ADC_DAP_LLNAC	0x2520
+#define AC_ADC_DAP_RHNAC	0x2522
+#define AC_ADC_DAP_RLNAC	0x2524
+#define AC_ADC_DAP_HHPFC	0x2526
+#define AC_ADC_DAP_LHPFC	0x2528
+#define AC_ADC_DAP_OPT		0x252A
+/* Left blank */
+#define AC_AGC_SEL		0x2480
+/* Left blank */
+#define AC_ADC_DAPL_CTRL	0x2500
+#define AC_ADC_DAPR_CTRL	0x2502
+#define AC_ADC_DAPLSTA		0x2504
+#define AC_ADC_DAPRSTA		0x2506
+#define AC_ADC_DAP_LTL		0x2508
+#define AC_ADC_DAP_RTL		0x250A
+#define AC_ADC_DAP_LHAC		0x250C
+#define AC_ADC_DAP_LLAC		0x250E
+#define AC_ADC_DAP_RHAC		0x2510
+#define AC_ADC_DAP_RLAC		0x2512
+#define AC_ADC_DAP_LDT		0x2514
+#define AC_ADC_DAP_LAT		0x2516
+#define AC_ADC_DAP_RDT		0x2518
+#define AC_ADC_DAP_RAT		0x251A
+#define AC_ADC_DAP_NTH		0x251C
+#define AC_ADC_DAP_LHNAC	0x251E
+#define AC_ADC_DAP_LLNAC	0x2520
+#define AC_ADC_DAP_RHNAC	0x2522
+#define AC_ADC_DAP_RLNAC	0x2524
+#define AC_ADC_DAP_HHPFC	0x2526
+#define AC_ADC_DAP_LHPFC	0x2528
+#define AC_ADC_DAP_OPT		0x252A
+/* Left blank */
+#define AC_DRC_SEL		0x2f80
+/* Left blank */
+#define AC_DRC_CHAN_CTRL	0x3000
+#define AC_DRC_HHPFC		0x3002
+#define AC_DRC_LHPFC		0x3004
+#define AC_DRC_CTRL		0x3006
+#define AC_DRC_LPFHAT		0x3008
+#define AC_DRC_LPFLAT		0x300A
+#define AC_DRC_RPFHAT		0x300C
+#define AC_DRC_RPFLAT		0x300E
+#define AC_DRC_LPFHRT		0x3010
+#define AC_DRC_LPFLRT		0x3012
+#define AC_DRC_RPFHRT		0x3014
+#define AC_DRC_RPFLRT		0x3016
+#define AC_DRC_LRMSHAT		0x3018
+#define AC_DRC_LRMSLAT		0x301A
+#define AC_DRC_RRMSHAT		0x301C
+#define AC_DRC_RRMSLAT		0x301E
+#define AC_DRC_HCT		0x3020
+#define AC_DRC_LCT		0x3022
+#define AC_DRC_HKC		0x3024
+#define AC_DRC_LKC		0x3026
+#define AC_DRC_HOPC		0x3028
+#define AC_DRC_LOPC		0x302A
+#define AC_DRC_HLT		0x302C
+#define AC_DRC_LLT		0x302E
+#define AC_DRC_HKI		0x3030
+#define AC_DRC_LKI		0x3032
+#define AC_DRC_HOPL		0x3034
+#define AC_DRC_LOPL		0x3036
+#define AC_DRC_HET		0x3038
+#define AC_DRC_LET		0x303A
+#define AC_DRC_HKE		0x303C
+#define AC_DRC_LKE		0x303E
+#define AC_DRC_HOPE		0x3040
+#define AC_DRC_LOPE		0x3042
+#define AC_DRC_HKN		0x3044
+#define AC_DRC_LKN		0x3046
+#define AC_DRC_SFHAT		0x3048
+#define AC_DRC_SFLAT		0x304A
+#define AC_DRC_SFHRT		0x304C
+#define AC_DRC_SFLRT		0x304E
+#define AC_DRC_MXGHS		0x3050
+#define AC_DRC_MXGLS		0x3052
+#define AC_DRC_MNGHS		0x3054
+#define AC_DRC_MNGLS		0x3056
+#define AC_DRC_EPSHC		0x3058
+#define AC_DRC_EPSLC		0x305A
+#define AC_DRC_OPT		0x305C
+#define AC_DRC_HPFHGAIN		0x305E
+#define AC_DRC_HPFLGAIN		0x3060
+#define AC_DRC_BISTCR		0x3100
+#define AC_DRC_BISTST		0x3102
+
+/* AC_SYS_CLK_CTL : 0x2000 */
+#define SYS_CLK_I2S		15
+#define SYS_CLK_AGC		7
+#define SYS_CLK_DRC		6
+#define SYS_CLK_ADC		3
+#define SYS_CLK_DAC		2
+
+/* AC_SYS_MOD_RST : 0x2002 */
+#define MOD_RST_I2S		15
+#define MOD_RST_AGC		7
+#define MOD_RST_DRC		6
+#define MOD_RST_ADC		3
+#define MOD_RST_DAC		2
+
+/* AC_SYS_SR_CTL : 0x2004 */
+#define SYS_SR_BIT		0
+#define SYS_SR_MASK		0xF
+#define SYS_SR_BIT_0		0	/* 8000 */
+#define SYS_SR_BIT_1		1	/* 11025 */
+#define SYS_SR_BIT_2		2	/* 12000 */
+#define SYS_SR_BIT_3		3	/* 16000 */
+#define SYS_SR_BIT_4		4	/* 22050 */
+#define SYS_SR_BIT_5		5	/* 24000 */
+#define SYS_SR_BIT_6		6	/* 32000 */
+#define SYS_SR_BIT_7		7	/* 44100 */
+#define SYS_SR_BIT_8		8	/* 48000 */
+#define SYS_SR_BIT_9		9	/* 96000 */
+#define SYS_SR_BIT_10		10	/* 192000 */
+
+/* AC_I2S_CTL : 0x2100 */
+#define I2S_SDO0_EN		3
+#define I2S_TX_EN		2
+#define I2S_RX_EN		1
+#define I2S_GEN			0
+
+/* AC_I2S_CLK : 0x2102 */
+#define I2S_BCLK_OUT		15
+#define I2S_LRCK_OUT		14
+#define I2S_BLCK_DIV		10
+#define I2S_LRCK_PERIOD		0
+/* BCLK DIV Define */
+#define I2S_BCLK_DIV_MASK	0xF
+#define I2S_BCLK_DIV_1		1
+#define I2S_BCLK_DIV_2		2
+#define I2S_BCLK_DIV_3		3
+#define I2S_BCLK_DIV_4		4
+#define I2S_BCLK_DIV_5		5
+#define I2S_BCLK_DIV_6		6
+#define I2S_BCLK_DIV_7		7
+#define I2S_BCLK_DIV_8		8
+#define I2S_BCLK_DIV_9		9
+#define I2S_BCLK_DIV_10		10
+#define I2S_BCLK_DIV_11		11
+#define I2S_BCLK_DIV_12		12
+#define I2S_BCLK_DIV_13		13
+#define I2S_BCLK_DIV_14		14
+#define I2S_BCLK_DIV_15		15
+#define I2S_LRCK_PERIOD_MASK	0x3FF
+
+/* AC_I2S_FMT0 : 0x2104 */
+#define I2S_FMT_MODE		14
+#define I2S_FMT_TX_OFFSET	10
+#define I2S_FMT_RX_OFFSET	8
+#define I2S_FMT_SAMPLE		4
+#define I2S_FMT_SLOT_WIDTH	1
+#define I2S_FMT_LOOP		0
+
+/* AC_I2S_FMT1 : 0x2108 */
+#define I2S_FMT_BCLK_POLAR	15
+#define I2S_FMT_LRCK_POLAR	14
+#define I2S_FMT_EDGE_TRANSFER	13
+#define I2S_FMT_RX_MLS		11
+#define I2S_FMT_TX_MLS		10
+#define I2S_FMT_EXTEND		9
+#define I2S_FMT_LRCK_WIDTH	4	/* PCM long/short Frame */
+#define I2S_MFT_RX_PDM		2
+#define I2S_FMT_TX_PDM		0
+
+/* AC_I2S_MIXER_SRC : 0x2114 */
+#define I2S_MIXERL_SRC_DAC	13
+#define I2S_MIXERL_SRC_ADC	12
+#define I2S_MIXERR_SRC_DAC	9
+#define I2S_MIXERR_SRC_ADC	8
+
+/* AC_I2S_MIXER_GAIN : 0x2116 */
+#define I2S_MIXERL_GAIN_DAC	13
+#define I2S_MIXERL_GAIN_ADC	12
+#define I2S_MIXERR_GAIN_DAC	9
+#define I2S_MIXERR_GAIN_ADC	8
+
+
+/* AC_I2S_DAC_VOL : 0x2118 */
+#define I2S_DACL_VOL		8
+#define I2S_DACR_VOL		0
+
+/* AC_I2S_ADC_VOL : 0x211A */
+#define I2S_ADCL_VOL		8
+#define I2S_ADCR_VOL		0
+
+/* AC_DAC_CTL : 0x2200 */
+#define DAC_CTL_DAC_EN		15
+#define DAC_CTL_HPF_EN		14
+#define DAC_CTL_FIR			13
+#define DAC_CTL_MODQU		8
+
+/* AC_DAC_MIXER_SRC : 0x2202 */
+#define DAC_MIXERL_SRC_DAC	13
+#define DAC_MIXERL_SRC_ADC	12
+#define DAC_MIXERR_SRC_DAC	9
+#define DAC_MIXERR_SRC_ADC	8
+
+/* AC_DAC_MIXER_GAIN : 0x2204 */
+#define DAC_MIXERL_GAIN_DAC	13
+#define DAC_MIXERL_GAIN_ADC	12
+#define DAC_MIXERR_GAIN_DAC	9
+#define DAC_MIXERR_GAIN_ADC	8
+
+/* AC_OUT_MIXER_CTL : 0x2220 */
+#define OUT_MIXER_DACR_EN	15
+#define OUT_MIXER_DACL_EN	14
+#define OUT_MIXER_RMIX_EN	13
+#define OUT_MIXER_LMIX_EN	12
+#define OUT_MIXER_LINE_VOL	8
+#define OUT_MIXER_MIC1_VOL	4
+#define OUT_MIXER_MIC2_VOL	0
+
+/* AC_OUT_MIXER_SRC : 0x2222 */
+#define OUT_MIXERR_SRC_MIC1	14
+#define OUT_MIXERR_SRC_MIC2	13
+#define OUT_MIXERR_SRC_PHPN	12
+#define OUT_MIXERR_SRC_PHP	11
+#define OUT_MIXERR_SRC_LINER	10
+#define OUT_MIXERR_SRC_DACR	9
+#define OUT_MIXERR_SRC_DACL	8
+#define OUT_MIXERL_SRC_MIC1	6
+#define OUT_MIXERL_SRC_MIC2	5
+#define OUT_MIXERL_SRC_PHPN	4
+#define OUT_MIXERL_SRC_PHN	3
+#define OUT_MIXERL_SRC_LINEL	2
+#define OUT_MIXERL_SRC_DACL	1
+#define OUT_MIXERL_SRC_DACR	0
+
+/* AC_LINEOUT_CTL : 0x2224 */
+#define LINEOUT_EN		15
+#define LINEL_SRC_EN		14
+#define LINER_SRC_EN		13
+#define LINEL_SRC		12
+#define LINER_SRC		11
+/* ramp just skip */
+#define LINE_SLOPE_SEL		8
+#define LINE_ANTI_TIME		5
+#define LINEOUT_VOL			0
+
+/* AC_ADC_CTL : 0x2300 */
+#define ADC_EN			15
+#define ADC_ENDM		14
+#define ADC_FIR			13
+#define ADC_DELAY_TIME		2
+#define ADC_DELAY_EN		1
+
+/* AC_MICBIAS_CTL : 0x2310 */
+#define MMBIAS_EN		15
+#define MMBIAS_CHOPPER	14
+#define MMBIAS_CHOP_CLK	12
+#define MMBIAS_SEL		8
+
+/* AC_ADC_MIC_CTL : 0x2320 */
+#define ADCR_EN			15
+#define ADCL_EN			14
+#define ADC_GAIN		8
+#define MIC1_GAIN_EN		7
+#define MIC1_BOOST		4
+#define MIC2_GAIN_EN		3
+#define MIC2_BOOST		0
+
+/* AC_ADC_MIXER_SRC : 0x2322 */
+#define ADC_MIXERR_MIC1		14
+#define ADC_MIXERR_MIC2		13
+#define ADC_MIXERR_PHPN		12
+#define ADC_MIXERR_PHP		11
+#define ADC_MIXERR_LINER	10
+#define ADC_MIXERR_MIXR		9
+#define ADC_MIXERR_MIXL		8
+#define ADC_MIXERL_MIC1		6
+#define ADC_MIXERL_MIC2		5
+#define ADC_MIXERL_PHPN		4
+#define ADC_MIXERL_PHN		3
+#define ADC_MIXERL_LINEL	2
+#define ADC_MIXERL_MIXL		1
+#define ADC_MIXERL_MIXR		0
+
+/* AC_BIAS_CTL : 0x232A */
+
+/* AC_ANALOG_PROF_CTL : 0x232C */
+/* used for current performance measure */
+
+/* AC_DLDO_OSC_CTL : 0x2340 */
+/* AC_ALDO_CTL : 0x2342 */
+/* used for digital & analog LDO test... etc */
+
+#endif
diff --git a/sound/soc/sunxi/sndhdmi.c b/sound/soc/sunxi/sndhdmi.c
new file mode 100644
index 000000000..661f1315c
--- /dev/null
+++ b/sound/soc/sunxi/sndhdmi.c
@@ -0,0 +1,391 @@
+/*
+ * sound\soc\sunxi\sndhdmi.c
+ * (C) Copyright 2014-2016
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * huangxin <huangxin@Reuuimllatech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <linux/io.h>
+#include <video/drv_hdmi.h>
+
+#include "sunxi_dma.h"
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+static bool  hdmiaudio_reset_en = false;
+#define hdmi_hw
+#ifdef hdmi_hw
+static __audio_hdmi_func 	g_hdmi_func;
+static hdmi_audio_t 		hdmi_para;
+#endif
+atomic_t pcm_count_num;
+
+#define SNDHDMI_RATES  (SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_KNOT)
+#define SNDHDMI_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \
+		                     SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+/*the struct just for register the hdmiaudio codec node*/
+struct sndhdmi_priv {
+	int sysclk;
+	int dai_fmt;
+
+	struct snd_pcm_substream *master_substream;
+	struct snd_pcm_substream *slave_substream;
+};
+#ifdef hdmi_hw
+void audio_set_hdmi_func(__audio_hdmi_func *hdmi_func)
+{
+	if (hdmi_func) {
+		g_hdmi_func.hdmi_audio_enable 	= hdmi_func->hdmi_audio_enable;
+		g_hdmi_func.hdmi_set_audio_para = hdmi_func->hdmi_set_audio_para;
+		g_hdmi_func.hdmi_is_playback = hdmi_func->hdmi_is_playback;
+	} else {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+	}
+}
+EXPORT_SYMBOL(audio_set_hdmi_func);
+#endif
+int sndhdmi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_card_get_drvdata(card);
+
+	#ifdef hdmi_hw
+	hdmi_para.sample_rate = params_rate(params);
+	hdmi_para.channel_num = params_channels(params);
+	hdmi_para.data_raw = sunxi_hdmi->hdmi_format;
+
+	switch (params_format(params))
+	{
+		case SNDRV_PCM_FORMAT_S16_LE:
+			hdmi_para.sample_bit = 16;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			hdmi_para.sample_bit = 24;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			hdmi_para.sample_bit = 24;
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			hdmi_para.sample_bit = 24;
+			break;
+		default:
+			return -EINVAL;
+	}
+	/*
+		PCM = 1,
+		AC3 = 2,
+		MPEG1 = 3,
+		MP3 = 4,
+		MPEG2 = 5,
+		AAC = 6,
+		DTS = 7,
+		ATRAC = 8,
+		ONE_BIT_AUDIO = 9,
+		DOLBY_DIGITAL_PLUS = 10,
+		DTS_HD = 11,
+		MAT = 12,
+		DST = 13,
+		WMAPRO = 14.
+	*/
+	if (hdmi_para.data_raw > 1) {
+		hdmi_para.sample_bit = 24; //??? TODO
+	}
+	pr_info("GYY : hdmi channel num is %d\n", hdmi_para.channel_num);
+	if (hdmi_para.channel_num == 8) {
+		hdmi_para.ca = 0x13;
+	} else if (hdmi_para.channel_num == 6) {
+		hdmi_para.ca = 0x0b;
+	} else if ((hdmi_para.channel_num >= 3)) {
+		hdmi_para.ca = 0x1f;
+	} else {
+		hdmi_para.ca = 0x0;
+	}
+	#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(sndhdmi_hw_params);
+static int sndhdmi_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int fmt)
+{
+	return 0;
+}
+int sndhdmi_prepare(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+//	u32 reg_val;
+#ifdef CONFIG_ARCH_SUN9I
+	int is_play = 0, i = 0;
+#endif
+//#if defined CONFIG_ARCH_SUN9I || defined CONFIG_ARCH_SUN8IW6
+//	/*Global Enable Digital Audio Interface*/
+//	reg_val = readl(SUNXI_I2S1_VBASE + SUNXI_I2S1CTL);
+//	reg_val |= SUNXI_I2S1CTL_GEN;
+//	writel(reg_val, SUNXI_I2S1_VBASE + SUNXI_I2S1CTL);
+//	msleep(10);
+//	/*flush TX FIFO*/
+//	reg_val = readl(SUNXI_I2S1_VBASE + SUNXI_I2S1FCTL);
+//    reg_val |= SUNXI_I2S1FCTL_FTX;
+//	writel(reg_val, SUNXI_I2S1_VBASE + SUNXI_I2S1FCTL);
+//#endif
+//#ifdef CONFIG_ARCH_SUN8IW7
+//	/*Global Enable Digital Audio Interface*/
+//	reg_val = readl(SUNXI_DAUDIO2_VBASE + SUNXI_DAUDIOCTL);
+//	reg_val |= SUNXI_DAUDIOCTL_GEN;
+//	writel(reg_val, SUNXI_DAUDIO2_VBASE + SUNXI_DAUDIOCTL);
+//	msleep(10);
+//	/*flush TX FIFO*/
+//	reg_val = readl(SUNXI_DAUDIO2_VBASE + SUNXI_DAUDIOFCTL);
+//	reg_val |= SUNXI_DAUDIOFCTL_FTX;
+//	writel(reg_val, SUNXI_DAUDIO2_VBASE + SUNXI_DAUDIOFCTL);
+//#endif
+#ifdef hdmi_hw
+	if ((hdmi_para.data_raw > 1)||(hdmi_para.sample_bit!=16)||(hdmi_para.channel_num != 2)||(hdmi_para.sample_rate != 44100)||( hdmiaudio_reset_en == true)) {
+		atomic_set(&pcm_count_num, 0);
+	} else {
+		atomic_inc(&pcm_count_num);
+	}
+	/*
+	*	set the first pcm param, need set the hdmi audio pcm param
+	*	set the data_raw param, need set the hdmi audio raw param
+	*/
+	if (!g_hdmi_func.hdmi_set_audio_para) {
+		pr_warn("hdmi video isn't insmod, hdmi interface is null\n");
+		return 0;
+	}
+	if (hdmiaudio_reset_en) {
+		pr_err("%s,l:%d,hdmi_para.data_raw:%d, hdmi_para.sample_bit:%d, hdmi_para.channel_num:%d, hdmi_para.sample_rate:%d, hdmiaudio_reset_en:%d\n",\
+			__func__, __LINE__, hdmi_para.data_raw, hdmi_para.sample_bit, hdmi_para.channel_num, hdmi_para.sample_rate, hdmiaudio_reset_en);
+	}
+	if (atomic_read(&pcm_count_num) <= 1) {
+		g_hdmi_func.hdmi_set_audio_para(&hdmi_para);
+		g_hdmi_func.hdmi_audio_enable(1, 1);
+	}
+
+#ifdef CONFIG_ARCH_SUN9I
+	is_play = g_hdmi_func.hdmi_is_playback();
+	i = 0;
+	while (!is_play) {
+		i++;
+		msleep(20);
+		if(i>50)
+			break;
+		is_play = g_hdmi_func.hdmi_is_playback();
+		if(is_play)
+			break;
+	}
+	is_play = g_hdmi_func.hdmi_is_playback();
+#endif
+
+#endif //hdmi_hw
+	return 0;
+}
+EXPORT_SYMBOL(sndhdmi_prepare);
+static int sndhdmi_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			} else {
+			}
+		break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			} else {
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+static int sunxi_sndhdmi_suspend(struct snd_soc_codec *dai)
+{
+	return 0;
+}
+
+static int sunxi_sndhdmi_resume(struct snd_soc_codec *dai)
+{
+	atomic_set(&pcm_count_num, 0);
+	return 0;
+}
+
+void sndhdmi_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	#ifdef hdmi_hw
+	if (g_hdmi_func.hdmi_audio_enable) {
+		g_hdmi_func.hdmi_audio_enable(0, 1);
+	}
+	#endif
+}
+EXPORT_SYMBOL(sndhdmi_shutdown);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void hdmiaudio_early_suspend(struct early_suspend *h) {
+
+}
+
+void hdmiaudio_late_resume(struct early_suspend *h) {
+	atomic_set(&pcm_count_num, 0);
+}
+
+ static struct early_suspend hdmiaudio_early_suspend_handler =
+{
+	.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+	.suspend = hdmiaudio_early_suspend,
+	.resume = hdmiaudio_late_resume,
+};
+#endif
+/*codec dai operation*/
+static struct snd_soc_dai_ops sndhdmi_dai_ops = {
+	.hw_params 	= sndhdmi_hw_params,
+	.set_fmt 	= sndhdmi_set_dai_fmt,
+	.trigger 	= sndhdmi_trigger,
+	.prepare  =	sndhdmi_prepare,
+	.shutdown 	= sndhdmi_shutdown,
+};
+
+/*codec dai*/
+static struct snd_soc_dai_driver sndhdmi_dai = {
+	.name 		= "sndhdmi",
+	/* playback capabilities */
+	.playback 	= {
+		.stream_name 	= "Playback",
+		.channels_min 	= 1,
+		.channels_max 	= 8,
+		.rates 			= SNDHDMI_RATES,
+		.formats 		= SNDHDMI_FORMATS,
+	},
+	/* pcm operations */
+	.ops 		= &sndhdmi_dai_ops,
+};
+EXPORT_SYMBOL(sndhdmi_dai);
+
+static int sndhdmi_soc_probe(struct snd_soc_codec *codec)
+{
+	struct sndhdmi_priv *sndhdmi = NULL;
+
+	atomic_set(&pcm_count_num, 0);
+	if (!codec) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+
+	sndhdmi = kzalloc(sizeof(struct sndhdmi_priv), GFP_KERNEL);
+	if (sndhdmi == NULL) {
+		pr_err("error at:%s,%d\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+
+	snd_soc_codec_set_drvdata(codec, sndhdmi);
+
+	return 0;
+}
+
+static int sndhdmi_soc_remove(struct snd_soc_codec *codec)
+{
+	struct sndhdmi_priv *sndhdmi = NULL;
+	if (!codec) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+	sndhdmi = snd_soc_codec_get_drvdata(codec);
+
+	kfree(sndhdmi);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_sndhdmi = {
+	.probe 	=	sndhdmi_soc_probe,
+	.remove =   sndhdmi_soc_remove,
+	.suspend 	= sunxi_sndhdmi_suspend,
+	.resume 	= sunxi_sndhdmi_resume,
+};
+
+static int sndhdmi_codec_probe(struct platform_device *pdev)
+{
+	if (!pdev) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+ #ifdef CONFIG_HAS_EARLYSUSPEND
+	register_early_suspend(&hdmiaudio_early_suspend_handler);
+ #endif
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_sndhdmi, &sndhdmi_dai, 1);
+}
+
+static int __exit sndhdmi_codec_remove(struct platform_device *pdev)
+{
+	if (!pdev) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+/*data relating*/
+static struct platform_device sndhdmi_codec_device = {
+	.name = "sunxi-hdmiaudio-codec",
+};
+static struct platform_driver sndhdmi_codec_driver = {
+	.driver = {
+		.name 	= "sunxi-hdmiaudio-codec",
+		.owner 	= THIS_MODULE,
+	},
+	.probe 	= sndhdmi_codec_probe,
+	.remove = __exit_p(sndhdmi_codec_remove),
+};
+
+static int __init sndhdmi_codec_init(void)
+{
+	int err = 0;
+	if ((err = platform_device_register(&sndhdmi_codec_device)) < 0)
+		return err;
+
+	if ((err = platform_driver_register(&sndhdmi_codec_driver)) < 0)
+		return err;
+
+	return 0;
+}
+module_init(sndhdmi_codec_init);
+module_param_named(hdmiaudio_reset_en, hdmiaudio_reset_en, bool, S_IRUGO | S_IWUSR);
+
+static void __exit sndhdmi_codec_exit(void)
+{
+	platform_driver_unregister(&sndhdmi_codec_driver);
+}
+module_exit(sndhdmi_codec_exit);
+
+MODULE_DESCRIPTION("SNDHDMI ALSA soc codec driver");
+MODULE_AUTHOR("huangxin, <huangxin@Reuuimllatech.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/sunxi/spdif-utils.c b/sound/soc/sunxi/spdif-utils.c
new file mode 100644
index 000000000..608439eee
--- /dev/null
+++ b/sound/soc/sunxi/spdif-utils.c
@@ -0,0 +1,78 @@
+/*
+ * ALSA SoC SPDIF DIT driver
+ *
+ *  This driver is used by controllers which can operate in DIT (SPDI/F) where
+ *  no codec is needed.  This file provides stub codec that can be used
+ *  in these configurations. TI DaVinci Audio controller uses this driver.
+ *
+ * Author:      Steve Chen,  <schen@mvista.com>
+ * Copyright:   (C) 2009 MontaVista Software, Inc., <source@mvista.com>
+ * Copyright:   (C) 2009  Texas Instruments, India
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+
+#define DRV_NAME "spdif-utils"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT
+#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | \
+			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE
+
+static struct snd_soc_codec_driver soc_codec_spdif_utils;
+
+static struct snd_soc_dai_driver spdif_stub_dai = {
+	.name		= "spdif-hifi",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static int spdif_utils_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_utils,
+			&spdif_stub_dai, 1);
+}
+
+static int spdif_utils_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver spdif_utils_driver = {
+	.probe		= spdif_utils_probe,
+	.remove		= spdif_utils_remove,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(spdif_utils_driver);
+
+MODULE_AUTHOR("Steve Chen <schen@mvista.com>");
+MODULE_DESCRIPTION("SPDIF dummy codec driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi/sunxi-sndahub.c b/sound/soc/sunxi/sunxi-sndahub.c
new file mode 100644
index 000000000..d8e72f8e8
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-sndahub.c
@@ -0,0 +1,407 @@
+/*
+ * sound\soc\sunxi\sunxi-sndhub.c
+ * (C) Copyright 2014-2018
+ * Allwinnertech Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+
+#include "sunxi_ahub.h"
+#include "sunxi_dma.h"
+
+/* Configuration for a stream */
+struct pcm_config {
+	unsigned int channels;
+	unsigned int rate;
+	unsigned format;
+};
+
+#define AHUB_MAX_DEVICE		3
+static struct pcm_config pcm[AHUB_MAX_DEVICE][2];
+
+static int event_bind_id;
+static struct sunxi_hdmi_priv sunxi_ahubhdmi;
+
+static int sunxi_ahubhdmi_set_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	sunxi_ahubhdmi.hdmi_format = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int sunxi_ahubhdmi_get_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sunxi_ahubhdmi.hdmi_format;
+	return 0;
+}
+
+static const char *ahubhdmi_format_function[] = {"null", "pcm", "AC3",
+	"MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC", "ONE_BIT_AUDIO",
+	"DOLBY_DIGITAL_PLUS", "DTS_HD", "MAT", "WMAPRO"};
+static const struct soc_enum ahubhdmi_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ahubhdmi_format_function),
+			ahubhdmi_format_function),
+};
+
+/* pcm dts ac3 Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_ahubhdmi_controls[] = {
+	SOC_ENUM_EXT("ahub audio format Function", ahubhdmi_format_enum[0],
+		sunxi_ahubhdmi_get_audio_mode, sunxi_ahubhdmi_set_audio_mode),
+};
+
+static struct snd_soc_dai *sunxi_ahub_get_dai_by_id(struct snd_soc_card *card,
+						int id)
+{
+	struct snd_soc_pcm_runtime *rtd;
+
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		if (rtd->codec_dai && (rtd->codec_dai->id == id))
+			return rtd->codec_dai;
+	}
+
+	return NULL;
+}
+
+static int sunxi_ahub_netlink_event(struct snd_soc_dapm_widget *w,
+			int stream, int event)
+{
+	struct snd_soc_card *card = w->dapm->card;
+	struct snd_soc_dai *codec_dai = sunxi_ahub_get_dai_by_id(card, event_bind_id);//card->rtd[event_bind_id].codec_dai;
+	int opt_open;
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		opt_open = 1;
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		opt_open = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* FIXME, as for AudioHub designed has three runtime, those runtime will
+	 * done it mess for some complex usage. so we just make sure allthing
+	 * work fine, we cut down diff sample rate playback or capture
+	 * do it at one time
+	 */
+
+	sunxi_netlink_printd("sunxi ahub event :%s : %ld :config=%ld/%ld/%ld/\n",
+			   w->name, (unsigned long)opt_open,
+			   (unsigned long)pcm[codec_dai->id][stream].channels,
+			   (unsigned long)pcm[codec_dai->id][stream].rate,
+			   (unsigned long)pcm[codec_dai->id][stream].format);
+
+	return 0;
+}
+
+static int sunxi_ahub_playback_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	return sunxi_ahub_netlink_event(w, 0, event);
+}
+
+static int sunxi_ahub_capture_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	return sunxi_ahub_netlink_event(w, 1, event);
+}
+
+static const struct snd_kcontrol_new sunxi_ahub_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("I2S0IN"),
+	SOC_DAPM_PIN_SWITCH("I2S0OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S1IN"),
+	SOC_DAPM_PIN_SWITCH("I2S1OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S2IN"),
+	SOC_DAPM_PIN_SWITCH("I2S2OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S3IN"),
+	SOC_DAPM_PIN_SWITCH("I2S3OUT"),
+	SOC_DAPM_PIN_SWITCH("DAM0IN"),
+	SOC_DAPM_PIN_SWITCH("DAM1IN"),
+	SOC_DAPM_PIN_SWITCH("DAM0OUT"),
+	SOC_DAPM_PIN_SWITCH("DAM1OUT"),
+};
+
+/* the input & output dir depends on view of audio hub */
+static const struct snd_soc_dapm_widget sunxi_ahub_card_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("I2S0IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S0OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S1IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S1OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S2IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S2OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S3IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S3OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("DAM0IN", NULL),
+	SND_SOC_DAPM_LINE("DAM1IN", NULL),
+	SND_SOC_DAPM_LINE("DAM0OUT", NULL),
+	SND_SOC_DAPM_LINE("DAM1OUT", NULL),
+};
+
+/* the input & output dir depends on view of audio hub */
+static const struct snd_soc_dapm_route sunxi_ahub_card_routes[] = {
+	{"I2S0 DAC", NULL, "I2S0IN"},
+	{"I2S1 DAC", NULL, "I2S1IN"},
+	{"I2S2 DAC", NULL, "I2S2IN"},
+	{"I2S3 DAC", NULL, "I2S3IN"},
+	{"I2S0OUT", NULL, "I2S0 ADC"},
+	{"I2S1OUT", NULL, "I2S1 ADC"},
+	{"I2S2OUT", NULL, "I2S2 ADC"},
+	{"I2S3OUT", NULL, "I2S3 ADC"},
+	{"DAM0 INPUT", NULL, "DAM0IN"},
+	{"DAM1 INPUT", NULL, "DAM1IN"},
+	{"DAM0OUT", NULL, "DAM0 OUTPUT"},
+	{"DAM1OUT", NULL, "DAM1 OUTPUT"},
+};
+
+static int sunxi_ahub_card_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S0IN");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S0OUT");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S1IN");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S1OUT");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S2IN");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S2OUT");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S3IN");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "I2S3OUT");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "DAM0IN");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "DAM1IN");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "DAM0OUT");
+	snd_soc_dapm_disable_pin(snd_soc_codec_get_dapm(codec), "DAM1OUT");
+
+	snd_soc_dapm_sync(snd_soc_codec_get_dapm(codec));
+	return 0;
+}
+
+static int sunxi_sndahub_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_card *card = rtd->card;
+	unsigned int freq;
+	int ret;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 98304000;
+#else
+		freq = 24576000;
+#endif
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+	case	88200:
+	case	176400:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		dev_err(card->dev, "unsupport freq\n");
+		return -EINVAL;
+	}
+
+	/*set system clock source freq and set the mode as i2s0 or pcm*/
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0 , freq, 0);
+	if (ret < 0)
+		return ret;
+
+	/*FIXME used for event send to observer process */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pcm[codec_dai->id][0].channels = params_channels(params);
+		pcm[codec_dai->id][0].rate = params_rate(params);
+		/* for HDMI raw_data, no residue mode, just make it double */
+		if (sunxi_ahub_get_rawflag() > 1)
+			pcm[codec_dai->id][0].format = SNDRV_PCM_FORMAT_S32_LE;
+		else
+			pcm[codec_dai->id][0].format = params_format(params);
+	} else {
+		pcm[codec_dai->id][1].channels = params_channels(params);
+		pcm[codec_dai->id][1].rate = params_rate(params);
+		if (sunxi_ahub_get_rawflag() > 1)
+			pcm[codec_dai->id][1].format = SNDRV_PCM_FORMAT_S32_LE;
+		else
+			pcm[codec_dai->id][1].format = params_format(params);
+	}
+
+	event_bind_id = codec_dai->id;
+
+	return 0;
+}
+
+static int sunxi_ahubhdmi_probe(struct snd_soc_card *card)
+{
+	int ret;
+
+	ret = snd_soc_add_card_controls(card, sunxi_ahubhdmi_controls,
+				ARRAY_SIZE(sunxi_ahubhdmi_controls));
+	if (ret)
+		dev_warn(card->dev, "Failed to register audio mode control\n");
+	return 0;
+}
+
+
+static struct snd_soc_ops sunxi_sndahub_ops = {
+	.hw_params	= sunxi_sndahub_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_sndahub_dai_link[] = {
+	{
+		.name = "Primary",
+		.stream_name = "Media Stream",
+		.codec_dai_name = "sunxi-ahub-aif1",
+		.init = sunxi_ahub_card_init,
+		.ops = &sunxi_sndahub_ops,
+	},
+	{
+		.name = "Sec",
+		.stream_name = "System Stream",
+		.codec_dai_name = "sunxi-ahub-aif2",
+		.ops = &sunxi_sndahub_ops,
+	},
+	{
+		.name = "Thr",
+		.stream_name = "Accompany Stream",
+		.codec_dai_name = "sunxi-ahub-aif3",
+		.ops = &sunxi_sndahub_ops,
+	},
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndahub = {
+	.name			= "sndahub",
+	.owner			= THIS_MODULE,
+	.controls		= sunxi_ahub_card_controls,
+	.num_controls		= ARRAY_SIZE(sunxi_ahub_card_controls),
+	.probe				= sunxi_ahubhdmi_probe,
+	.dapm_widgets		= sunxi_ahub_card_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(sunxi_ahub_card_dapm_widgets),
+	.dapm_routes		= sunxi_ahub_card_routes,
+	.num_dapm_routes	= ARRAY_SIZE(sunxi_ahub_card_routes),
+	.dai_link		= sunxi_sndahub_dai_link,
+	.num_links		= ARRAY_SIZE(sunxi_sndahub_dai_link),
+};
+
+static int sunxi_sndahub_dev_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_sunxi_sndahub;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+	int i;
+
+	card->dev = &pdev->dev;
+
+	sunxi_sndahub_dai_link[0].cpu_dai_name = NULL;
+	sunxi_sndahub_dai_link[0].cpu_of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller0", 0);
+	if (!sunxi_sndahub_dai_link[0].cpu_of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller0' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[0].platform_name = NULL;
+		sunxi_sndahub_dai_link[0].platform_of_node =
+				sunxi_sndahub_dai_link[0].cpu_of_node;
+	}
+
+	sunxi_sndahub_dai_link[1].cpu_dai_name = NULL;
+	sunxi_sndahub_dai_link[1].cpu_of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller1", 0);
+	if (!sunxi_sndahub_dai_link[1].cpu_of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller1' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[1].platform_name = NULL;
+		sunxi_sndahub_dai_link[1].platform_of_node =
+				sunxi_sndahub_dai_link[1].cpu_of_node;
+	}
+
+	sunxi_sndahub_dai_link[2].cpu_dai_name = NULL;
+	sunxi_sndahub_dai_link[2].cpu_of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller2", 0);
+	if (!sunxi_sndahub_dai_link[2].cpu_of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller0' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[2].platform_name = NULL;
+		sunxi_sndahub_dai_link[2].platform_of_node =
+				sunxi_sndahub_dai_link[2].cpu_of_node;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sunxi_sndahub_dai_link); i++) {
+		sunxi_sndahub_dai_link[i].codec_name = NULL;
+		sunxi_sndahub_dai_link[i].codec_of_node = of_parse_phandle(np,
+							"sunxi,audio-codec", 0);
+	}
+
+	snd_soc_card_set_drvdata(card, &sunxi_ahubhdmi);
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
+			ret);
+	}
+	return ret;
+}
+
+static int __exit sunxi_sndahub_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_ahubaudio_driver = {
+	.driver = {
+		.name = "sndahub",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = sunxi_sndahub_dev_probe,
+	.remove = __exit_p(sunxi_sndahub_dev_remove),
+};
+
+module_platform_driver(sunxi_ahubaudio_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub ASoC Machine driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-snddaudio.c b/sound/soc/sunxi/sunxi-snddaudio.c
new file mode 100644
index 000000000..95e4dd1a6
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-snddaudio.c
@@ -0,0 +1,353 @@
+/*
+ * sound\soc\sunxi\sunxi_snddaudio.c
+ * (C) Copyright 2014-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang Huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+static atomic_t daudio_count = ATOMIC_INIT(-1);
+
+static int sunxi_snddaudio_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card *card = rtd->card;
+	unsigned int freq, clk_div;
+	int ret;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 98304000;
+#else
+		freq = 24576000;
+#endif
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		dev_err(card->dev, "unsupport params rate\n");
+		return -EINVAL;
+	}
+	/* set platform clk source freq and set the mode as daudio or pcm */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, freq, 0);
+	if (ret < 0)
+		return ret;
+
+	/* set codec clk source freq and set the mode as daudio or pcm */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+	if (ret < 0)
+		dev_warn(card->dev, "codec_dai set sysclk failed\n");
+
+	/* set codec dai fmt */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		dev_warn(card->dev, "codec dai set fmt failed\n");
+
+	/* set system clk div */
+	clk_div = freq / params_rate(params);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, clk_div);
+	if (ret < 0)
+		dev_warn(card->dev, "codec_dai set clkdiv failed\n");
+	return 0;
+}
+
+/* sunxi card initialization */
+static int sunxi_snddaudio_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_snddaudio_ops = {
+	.hw_params      = sunxi_snddaudio_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_snddaudio_dai_link = {
+	.name           = "sysvoice",
+	.stream_name    = "SUNXI-AUDIO",
+	.cpu_dai_name   = "sunxi-daudio",
+	.platform_name  = "sunxi-daudio",
+	.codec_dai_name = "snd-soc-dummy-dai",
+	.codec_name     = "snd-soc-dummy",
+	.init           = sunxi_snddaudio_init,
+	.ops            = &sunxi_snddaudio_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_snddaudio = {
+	.name           = "snddaudio",
+	.owner          = THIS_MODULE,
+	.num_links      = 1,
+};
+#if 1//defined(CONFIG_SND_SUNXI_SOC_AHUB) || defined(CONFIG_SND_SUNXI_SOC_AHUB_MODULE)
+static int sunxi_snddaudio_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link	*dai_link;
+	struct snd_soc_card *card;
+	char name[30] = "snddaudio";
+	unsigned int temp_val;
+	int ret = 0;
+
+	card = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_card),
+			GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	memcpy(card, &snd_soc_sunxi_snddaudio, sizeof(struct snd_soc_card));
+
+	card->dev = &pdev->dev;
+
+	dai_link = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_link), GFP_KERNEL);
+	if (!dai_link) {
+		ret = -ENOMEM;
+		goto err_kfree_card;
+	}
+
+	memcpy(dai_link, &sunxi_snddaudio_dai_link,
+			sizeof(struct snd_soc_dai_link));
+	card->dai_link = dai_link;
+
+	dai_link->cpu_dai_name = NULL;
+	dai_link->cpu_of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!dai_link->cpu_of_node) {
+		dev_err(&pdev->dev,
+			"Property 'sunxi,cpudai-controller' invalid\n");
+		ret = -EINVAL;
+		goto err_kfree_link;
+	}
+	printk("cpu dai of node: %x\n", dai_link->cpu_of_node);
+	dai_link->platform_name = "snd-soc-dummy";
+
+	ret = of_property_read_string(np, "sunxi,snddaudio-codec",
+			&dai_link->codec_name);
+	/*
+	 * As we setting codec & codec_dai in dtb, we just setting the
+	 * codec & codec_dai in the dai_link. But if we just not setting,
+	 * we then using the snd-soc-dummy as the codec & codec_dai to
+	 * construct the snd-card for audio playback & capture.
+	 */
+	if (!ret) {
+		ret = of_property_read_string(np, "sunxi,snddaudio-codec-dai",
+				&dai_link->codec_dai_name);
+		if (ret < 0) {
+			dev_err(card->dev, "codec_dai name invaild in dtb\n");
+			ret = -EINVAL;
+			goto err_kfree_link;
+		}
+		sprintf(name+3, "%s", dai_link->codec_name);
+	} else {
+		if (dai_link->cpu_of_node && of_property_read_u32(
+			dai_link->cpu_of_node, "tdm_num", &temp_val) >= 0)
+			sprintf(name+9, "%u", temp_val);
+		else
+			sprintf(name+9, "%d", atomic_inc_return(&daudio_count));
+	}
+
+	card->name = name;
+	dev_info(card->dev, "codec: %s, codec_dai: %s.\n",
+			dai_link->codec_name,
+			dai_link->codec_dai_name);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(card->dev, "snd_soc_register_card failed\n");
+		goto err_kfree_link;
+	}
+
+	return ret;
+err_kfree_link:
+	devm_kfree(&pdev->dev, card->dai_link);
+err_kfree_card:
+	devm_kfree(&pdev->dev, card);
+	return ret;
+}
+#else
+static int sunxi_snddaudio_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link	*dai_link;
+	struct snd_soc_card *card;
+	char name[30] = "snddaudio";
+	unsigned int temp_val;
+	int ret = 0;
+
+	card = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_card),
+			GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	memcpy(card, &snd_soc_sunxi_snddaudio, sizeof(struct snd_soc_card));
+
+	card->dev = &pdev->dev;
+
+	card->dev = &pdev->dev;
+
+	dai_link = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_link), GFP_KERNEL);
+	if (!dai_link) {
+		ret = -ENOMEM;
+		goto err_kfree_card;
+	}
+	memcpy(dai_link, &sunxi_snddaudio_dai_link,
+			sizeof(struct snd_soc_dai_link));
+	card->dai_link = dai_link;
+
+	dai_link->cpu_dai_name = NULL;
+	dai_link->cpu_of_node = of_parse_phandle(np,
+			"sunxi,daudio0-controller", 0);
+	if (dai_link->cpu_of_node)
+		goto cpu_node_find;
+
+	dai_link->cpu_of_node = of_parse_phandle(np,
+			"sunxi,daudio1-controller", 0);
+	if (dai_link->cpu_of_node)
+		goto cpu_node_find;
+
+	dai_link->cpu_of_node = of_parse_phandle(np,
+			"sunxi,daudio-controller", 0);
+	if (dai_link->cpu_of_node)
+		goto cpu_node_find;
+
+	dev_err(card->dev, "Perperty 'sunxi,daudio-controller' missing\n");
+
+	goto err_kfree_link;
+
+cpu_node_find:
+	dai_link->platform_name = NULL;
+	dai_link->platform_of_node =
+				dai_link->cpu_of_node;
+
+	ret = of_property_read_string(np, "sunxi,snddaudio-codec",
+			&dai_link->codec_name);
+	/*
+	 * As we setting codec & codec_dai in dtb, we just setting the
+	 * codec & codec_dai in the dai_link. But if we just not setting,
+	 * we then using the snd-soc-dummy as the codec & codec_dai to
+	 * construct the snd-card for audio playback & capture.
+	 */
+	if (!ret) {
+		ret = of_property_read_string(np, "sunxi,snddaudio-codec-dai",
+				&dai_link->codec_dai_name);
+		if (ret < 0) {
+			dev_err(card->dev, "codec_dai name invaild in dtb\n");
+			ret = -EINVAL;
+			goto err_kfree_link;
+		}
+		sprintf(name+3, "%s", dai_link->codec_name);
+	} else {
+		if (dai_link->cpu_of_node && of_property_read_u32(
+			dai_link->cpu_of_node, "tdm_num", &temp_val) >= 0)
+			sprintf(name+9, "%u", temp_val);
+		else
+			sprintf(name+9, "%d", atomic_inc_return(&daudio_count));
+	}
+
+	card->name = name;
+	dev_info(card->dev, "codec: %s, codec_dai: %s.\n",
+			dai_link->codec_name,
+			dai_link->codec_dai_name);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(card->dev, "snd_soc_register_card failed\n");
+		goto err_kfree_link;
+	}
+
+	return ret;
+
+err_kfree_link:
+	devm_kfree(&pdev->dev, card->dai_link);
+err_kfree_card:
+	devm_kfree(&pdev->dev, card);
+	return ret;
+}
+#endif
+
+static int sunxi_snddaudio_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	devm_kfree(&pdev->dev, card->dai_link);
+	snd_soc_unregister_card(card);
+	devm_kfree(&pdev->dev, card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_snddaudio_of_match[] = {
+	{ .compatible = "allwinner,sunxi-daudio0-machine", },
+	{ .compatible = "allwinner,sunxi-daudio1-machine", },
+	{ .compatible = "allwinner,sunxi-daudio2-machine", },
+	{ .compatible = "allwinner,sunxi-daudio3-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_snddaudio_driver = {
+	.driver = {
+		.name   = "snddaudio",
+		.owner  = THIS_MODULE,
+		.pm     = &snd_soc_pm_ops,
+		.of_match_table = sunxi_snddaudio_of_match,
+	},
+	.probe  = sunxi_snddaudio_dev_probe,
+	.remove = sunxi_snddaudio_dev_remove,
+};
+
+static int __init sunxi_snddaudio_driver_init(void)
+{
+		return platform_driver_register(&sunxi_snddaudio_driver);
+}
+
+static void __exit sunxi_snddaudio_driver_exit(void)
+{
+		platform_driver_unregister(&sunxi_snddaudio_driver);
+}
+
+late_initcall(sunxi_snddaudio_driver_init);
+module_exit(sunxi_snddaudio_driver_exit);
+
+MODULE_AUTHOR("Wolfgang Huang");
+MODULE_DESCRIPTION("SUNXI snddaudio ALSA SoC Audio Card Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-snddmic.c b/sound/soc/sunxi/sunxi-snddmic.c
new file mode 100644
index 000000000..3e83e9d09
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-snddmic.c
@@ -0,0 +1,171 @@
+/*
+ * sound\soc\sunxi\sunxi_snddmic.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+static int sunxi_snddmic_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+	int freq;
+
+	switch (params_rate(params)) {
+	case	8000:
+	case	16000:
+	case	32000:
+	case	12000:
+	case	24000:
+	case	48000:
+	case	96000:
+	case	192000:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 98304000;
+#else
+		freq = 24576000;
+#endif
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+	case	88200:
+	case	176400:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		pr_debug("invalid rate setting\n");
+		return -EINVAL;
+		break;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , freq, 0);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_snddmic_ops = {
+	.hw_params 	= sunxi_snddmic_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_snddmic_dai_link = {
+	.name		= "DMIC",
+	.stream_name	= "SUNXI-DMIC",
+	.cpu_dai_name	= "sunxi-dmic",
+	.platform_name	= "sunxi-dmic",
+	.codec_name	= "dmic-codec",
+	.codec_dai_name = "dmic-hifi",
+	.ops		= &sunxi_snddmic_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_snddmic = {
+	.name 		= "snddmic",
+	.owner 		= THIS_MODULE,
+	.dai_link 	= &sunxi_snddmic_dai_link,
+	.num_links 	= 1,
+};
+
+static int sunxi_snddmic_dev_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct snd_soc_card *card = &snd_soc_sunxi_snddmic;
+	struct device_node *np = pdev->dev.of_node;
+	struct platform_device *sunxi_snd_dmic_codec_device;
+	card->dev = &pdev->dev;
+
+	sunxi_snddmic_dai_link.cpu_dai_name = NULL;
+	sunxi_snddmic_dai_link.cpu_of_node = of_parse_phandle(np,
+					"sunxi,dmic-controller", 0);
+	if (!sunxi_snddmic_dai_link.cpu_of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,dmic-controller' missing or invalid\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	sunxi_snddmic_dai_link.platform_name = NULL;
+	sunxi_snddmic_dai_link.platform_of_node = sunxi_snddmic_dai_link.cpu_of_node;
+
+	sunxi_snd_dmic_codec_device = platform_device_alloc("dmic-codec", -1);
+	if (!sunxi_snd_dmic_codec_device) {
+		dev_err(&pdev->dev, "dmic codec alloc failed\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = platform_device_add(sunxi_snd_dmic_codec_device);
+	if (ret) {
+		dev_err(&pdev->dev, "dmic codec add failed\n");
+		ret = -EBUSY;
+		goto err_dmic_put;
+	}
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+		ret = -EBUSY;
+		goto err_dmic_del;
+	}
+	return ret;
+
+err_dmic_del:
+	platform_device_del(sunxi_snd_dmic_codec_device);
+err_dmic_put:
+	platform_device_put(sunxi_snd_dmic_codec_device);
+	return ret;
+}
+
+static int sunxi_snddmic_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_dmic_of_match[] = {
+	{ .compatible = "allwinner,sunxi-dmic-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_dmic_driver = {
+	.driver = {
+		.name = "snddmic",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_dmic_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = sunxi_snddmic_dev_probe,
+	.remove = sunxi_snddmic_dev_remove,
+};
+
+module_platform_driver(sunxi_dmic_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI DMIC Machine ASoC driver");
+MODULE_ALIAS("platform:snddmic");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-sndhdmi.c b/sound/soc/sunxi/sunxi-sndhdmi.c
new file mode 100644
index 000000000..c59d94680
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-sndhdmi.c
@@ -0,0 +1,227 @@
+/*
+ * sound\soc\sunxi\sunxi-sndhdmi.c
+ * (C) Copyright 2014-2016
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * huangxin <huangxin@Reuuimllatech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+#include "sunxi_dma.h"
+
+static struct sunxi_hdmi_priv sunxi_tdmhdmi;
+
+static int sunxi_hdmiaudio_set_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	sunxi_tdmhdmi.hdmi_format = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int sunxi_hdmiaudio_get_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sunxi_tdmhdmi.hdmi_format;
+	return 0;
+}
+
+static const char *hdmiaudio_format_function[] = {"null", "pcm", "AC3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC", "ONE_BIT_AUDIO", "DOLBY_DIGITAL_PLUS", "DTS_HD", "MAT", "WMAPRO"};
+static const struct soc_enum hdmiaudio_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(hdmiaudio_format_function),
+			hdmiaudio_format_function),
+};
+
+/* pcm dts ac3 Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_hdmiaudio_controls[] = {
+	SOC_ENUM_EXT("hdmi audio format Function", hdmiaudio_format_enum[0],
+		sunxi_hdmiaudio_get_audio_mode, sunxi_hdmiaudio_set_audio_mode),
+};
+
+static int sunxi_sndhdmi_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card *card = rtd->card;
+	unsigned int freq;
+	unsigned int clk_div;
+	int ret;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 98304000;
+#else
+		freq = 24576000;
+#endif
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+	case	88200:
+	case	176400:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		dev_err(card->dev, "unsupport freq\n");
+		return -EINVAL;
+	}
+
+	/*set system clock source freq and set the mode as i2s0 or pcm*/
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , freq, 0);
+	if (ret < 0) {
+		return ret;
+	}
+
+	/*
+	* I2S mode \normal bit clock + frame\codec clk & FRM slave
+	*/
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0) {
+		return ret;
+	}
+
+	clk_div = freq / params_rate(params);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+	if (ret < 0) {
+		return ret;
+	}
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndhdmi_ops = {
+	.hw_params 	= sunxi_sndhdmi_hw_params,
+};
+
+static int sunxi_sndhdmi_probe(struct snd_soc_card *card)
+{
+	int ret;
+
+	ret = snd_soc_add_card_controls(card, sunxi_hdmiaudio_controls,
+				ARRAY_SIZE(sunxi_hdmiaudio_controls));
+	if (ret)
+		dev_warn(card->dev, "Failed to register audio mode control, will continue without it.\n");
+	return 0;
+}
+
+static struct snd_soc_dai_link sunxi_sndhdmi_dai_link = {
+	.name	= "HDMIAUDIO",
+	.stream_name	= "SUNXI-HDMIAUDIO",
+	.cpu_dai_name	= "sunxi-hdmiaudio.0",
+	.codec_dai_name	= "sndhdmi",
+	.platform_name	= "sunxi-hdmiaudio-pcm-audio.0",
+	.codec_name	= "sunxi-hdmiaudio-codec.0",
+	.ops		= &sunxi_sndhdmi_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndhdmi = {
+	.name 		= "sndhdmi",
+	.owner 		= THIS_MODULE,
+	.probe		= sunxi_sndhdmi_probe,
+	.dai_link 	= &sunxi_sndhdmi_dai_link,
+	.num_links 	= 1,
+};
+
+static int sunxi_sndhdmi_dev_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_sunxi_sndhdmi;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	card->dev = &pdev->dev;
+	sunxi_tdmhdmi.hdmi_format = 1;
+#ifdef CONFIG_SND_SUNXI_SOC_AHUB
+	sunxi_sndhdmi_dai_link.cpu_dai_name = NULL;
+	sunxi_sndhdmi_dai_link.cpu_of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!sunxi_sndhdmi_dai_link.cpu_of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller' missing or invalid\n");
+		return -EINVAL;
+	}
+	sunxi_sndhdmi_dai_link.platform_name = "snd-soc-dummy";
+#else
+	if (np) {
+		sunxi_sndhdmi_dai_link.cpu_dai_name = NULL;
+		sunxi_sndhdmi_dai_link.cpu_of_node = of_parse_phandle(np,
+					"sunxi,hdmi-controller", 0);
+		if (!sunxi_sndhdmi_dai_link.cpu_of_node) {
+			dev_err(&pdev->dev,
+				"Property 'sunxi,hdmi-controller' missing or invalid\n");
+			ret = -EINVAL;
+		}
+		sunxi_sndhdmi_dai_link.platform_name = NULL;
+		sunxi_sndhdmi_dai_link.platform_of_node = sunxi_sndhdmi_dai_link.cpu_of_node;
+	} else {
+		dev_err(&pdev->dev,"hdmi dt node missing or invalid\n");
+		ret = -EINVAL;
+	}
+#endif
+
+	snd_soc_card_set_drvdata(card, &sunxi_tdmhdmi);
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
+			ret);
+	}
+	return ret;
+}
+
+static int __exit sunxi_sndhdmi_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_hdmi_of_match[] = {
+	{ .compatible = "allwinner,sunxi-hdmi-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_hdmiaudio_driver = {
+	.driver = {
+		.name = "sndhdmi",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_hdmi_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = sunxi_sndhdmi_dev_probe,
+	.remove = __exit_p(sunxi_sndhdmi_dev_remove),
+};
+
+module_platform_driver(sunxi_hdmiaudio_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI HDMI ASoC Machine driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-sndspdif.c b/sound/soc/sunxi/sunxi-sndspdif.c
new file mode 100644
index 000000000..b71ed628e
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-sndspdif.c
@@ -0,0 +1,172 @@
+/*
+ * sound\soc\sunxi\sunxi_sndspdif.c
+ * (C) Copyright 2010-2016
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include "sunxi_spdif.h"
+// #include "codec-utils.h"
+
+static int sunxi_sndspdif_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret, clk_div;
+	unsigned int freq;
+
+	switch(params_rate(params)) {
+	case	24000:
+	case	32000:
+	case	48000:
+	case	96000:
+	case	192000:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 98304000;
+#else
+		freq = 24576000;
+#endif
+		break;
+	case	22050:
+	case	44100:
+	case	176400:
+#ifdef CONFIG_AHUB_FREQ_REQ
+		freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		pr_debug("[sunxi spdif]Invalid rate\n");
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , freq, 0);
+	if (ret < 0)
+		return ret;
+
+	clk_div = freq/params_rate(params);
+	clk_div = clk_div>>7;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+	if(ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndspdif_ops = {
+	.hw_params 	= sunxi_sndspdif_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_sndspdif_dai_link = {
+	.name 			= "SPDIF",
+	.stream_name 	= "SUNXI-SPDIF",
+	.cpu_dai_name 	= "sunxi-spdif",
+	.platform_name 	= "sunxi-spdif",
+	.codec_dai_name = "spdif-hifi",
+	.codec_name	= "spdif-utils",
+	.ops 		= &sunxi_sndspdif_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndspdif = {
+	.name 		= "sndspdif",
+	.owner 		= THIS_MODULE,
+	.dai_link 	= &sunxi_sndspdif_dai_link,
+	.num_links 	= 1,
+};
+
+static int sunxi_sndspdif_dev_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct snd_soc_card *card = &snd_soc_sunxi_sndspdif;
+	struct device_node *np = pdev->dev.of_node;
+	struct platform_device *sunxi_snd_spdif_utils_device;
+
+	card->dev = &pdev->dev;
+	sunxi_sndspdif_dai_link.cpu_dai_name = NULL;
+	sunxi_sndspdif_dai_link.cpu_of_node = of_parse_phandle(np,
+				"sunxi,spdif-controller", 0);
+	if (!sunxi_sndspdif_dai_link.cpu_of_node) {
+		dev_err(&pdev->dev,
+			"Property 'sunxi,spdif-controller' missing or invalid\n");
+			ret = -EINVAL;
+	}
+	sunxi_sndspdif_dai_link.platform_name = NULL;
+	sunxi_sndspdif_dai_link.platform_of_node = sunxi_sndspdif_dai_link.cpu_of_node;
+
+	sunxi_snd_spdif_utils_device = platform_device_alloc("spdif-utils", -1);
+	if(sunxi_snd_spdif_utils_device == NULL) {
+		dev_err(&pdev->dev, "spdif utils alloc failed\n");
+		return -ENOMEM;
+	}
+
+	ret = platform_device_add(sunxi_snd_spdif_utils_device);
+	if(ret) {
+		dev_err(&pdev->dev, "spdif utils add failed\n");
+		ret = -EBUSY;
+		goto err_utils_put;
+	}
+	
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+		ret = -EBUSY;
+		goto err_utils_del;
+	}
+	return ret;
+
+err_utils_del:
+	platform_device_del(sunxi_snd_spdif_utils_device);
+err_utils_put:
+	platform_device_put(sunxi_snd_spdif_utils_device);
+	return ret;
+}
+
+static int sunxi_sndspdif_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_spdif_of_match[] = {
+	{ .compatible = "allwinner,sunxi-spdif-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_spdif_driver = {
+	.driver = {
+		.name = "sndspdif",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_spdif_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = sunxi_sndspdif_dev_probe,
+	.remove = sunxi_sndspdif_dev_remove,
+};
+
+module_platform_driver(sunxi_spdif_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI SPDIF ASoC audio driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sndspdif");
diff --git a/sound/soc/sunxi/sunxi_ahub.c b/sound/soc/sunxi/sunxi_ahub.c
new file mode 100644
index 000000000..497b219d5
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_ahub.c
@@ -0,0 +1,931 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub.c
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/pm.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "sunxi_ahub.h"
+#include "sunxi_dma.h"
+
+#define DRV_NAME	"sunxi-ahub"
+
+struct sunxi_ahub_priv {
+	struct device *dev;
+	void __iomem *membase;
+	struct regmap *regmap;
+	struct clk *pllclk;
+	struct clk *moduleclk;
+} sunxi_ahub_dev;
+
+static struct sunxi_ahub_priv *sunxi_ahub = &sunxi_ahub_dev;
+
+static const struct regmap_config sunxi_ahub_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_AHUB_DAM_GAIN_CTL7(1),
+	.cache_type = REGCACHE_RBTREE,
+};
+
+unsigned int sunxi_ahub_read(unsigned int reg)
+{
+	return readl(sunxi_ahub->membase + reg);
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_read);
+
+/* reslove conflict with regmap_update_bits using spin_lock */
+int sunxi_ahub_update_bits(
+					unsigned int reg,
+			       unsigned int mask, unsigned int val)
+{
+	unsigned int tmp, orig;
+
+	orig = readl(sunxi_ahub->membase + reg);
+
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+
+	if (tmp != orig)
+		writel(tmp, sunxi_ahub->membase + reg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_update_bits);
+
+struct regmap *sunxi_ahub_regmap_init(struct platform_device *pdev)
+{
+	struct resource res, *memregion;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (!sunxi_ahub->regmap) {
+		ret = of_address_to_resource(np, 0, &res);
+		if (ret)
+			return NULL;
+
+		memregion = devm_request_mem_region(&pdev->dev, res.start,
+						resource_size(&res), DRV_NAME);
+		if (!memregion)
+			return NULL;
+
+		sunxi_ahub->membase = ioremap(res.start, resource_size(&res));
+		if (!sunxi_ahub->membase)
+			return NULL;
+
+		sunxi_ahub->regmap = devm_regmap_init_mmio(&pdev->dev,
+						sunxi_ahub->membase,
+						&sunxi_ahub_regmap_config);
+		if (IS_ERR_OR_NULL(sunxi_ahub->regmap)) {
+			ret = PTR_ERR(sunxi_ahub->regmap);
+			return NULL;
+		}
+	}
+	return sunxi_ahub->regmap;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_regmap_init);
+static const char * const apbif_mux_text[] = {
+	"NONE",
+	"APBIF_TXDIF0",
+	"APBIF_TXDIF1",
+	"APBIF_TXDIF2",
+	"I2S0_TXDIF",
+	"I2S1_TXDIF",
+	"I2S2_TXDIF",
+	"I2S3_TXDIF",
+	"DAM0_TXDIF",
+	"DAM1_TXDIF",
+};
+static const unsigned int apbif_mux_values[] = {
+	0,
+	1<<I2S_RX_APBIF_TXDIF0,
+	1<<I2S_RX_APBIF_TXDIF1,
+	1<<I2S_RX_APBIF_TXDIF2,
+	1<<I2S_RX_I2S0_TXDIF,
+	1<<I2S_RX_I2S1_TXDIF,
+	1<<I2S_RX_I2S2_TXDIF,
+	1<<I2S_RX_I2S3_TXDIF,
+	1<<I2S_RX_DAM0_TXDIF,
+	1<<I2S_RX_DAM1_TXDIF,
+};
+
+#define AHUB_MUX_ENUM_DECL(name, reg)	\
+	SOC_VALUE_ENUM_SINGLE_DECL(name, reg, 0, 0xffffffff,	\
+			apbif_mux_text, apbif_mux_values)
+
+static AHUB_MUX_ENUM_DECL(apbif0, SUNXI_AHUB_APBIF_RXFIFO_CONT(0));
+static AHUB_MUX_ENUM_DECL(apbif1, SUNXI_AHUB_APBIF_RXFIFO_CONT(1));
+static AHUB_MUX_ENUM_DECL(apbif2, SUNXI_AHUB_APBIF_RXFIFO_CONT(2));
+static AHUB_MUX_ENUM_DECL(i2s0, SUNXI_AHUB_I2S_RXCONT(0));
+static AHUB_MUX_ENUM_DECL(i2s1, SUNXI_AHUB_I2S_RXCONT(1));
+static AHUB_MUX_ENUM_DECL(i2s2, SUNXI_AHUB_I2S_RXCONT(2));
+static AHUB_MUX_ENUM_DECL(i2s3, SUNXI_AHUB_I2S_RXCONT(3));
+static AHUB_MUX_ENUM_DECL(dam0chan0, SUNXI_AHUB_DAM_RX0_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam0chan1, SUNXI_AHUB_DAM_RX1_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam0chan2, SUNXI_AHUB_DAM_RX2_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam1chan0, SUNXI_AHUB_DAM_RX0_SRC(1));
+static AHUB_MUX_ENUM_DECL(dam1chan1, SUNXI_AHUB_DAM_RX1_SRC(1));
+static AHUB_MUX_ENUM_DECL(dam1chan2, SUNXI_AHUB_DAM_RX2_SRC(1));
+
+
+#define APBIF_RX_MUX_CONTROLS(num)					\
+static const struct snd_kcontrol_new apbif##num##_rx_mux =		\
+	SOC_DAPM_ENUM("APBIF##num Rx Mux", apbif##num);
+
+#define I2S_RX_MUX_CONTROLS(num)					\
+static const struct snd_kcontrol_new i2s##num##_rx_mux =		\
+	SOC_DAPM_ENUM("I2S##num RX Mux", i2s##num);
+
+#define DAM0_RX_MUX_CONTROLS(chan)					\
+static const struct snd_kcontrol_new  dam0chan##chan##_rx_mux =		\
+	SOC_DAPM_ENUM("DAM0 Chan##chan Rx Mux", dam0chan##chan);
+#define DAM1_RX_MUX_CONTROLS(chan)                                       \
+static const struct snd_kcontrol_new dam1chan##chan##_rx_mux =           \
+	SOC_DAPM_ENUM("DAM1 Chan##chan Rx Mux", dam1chan##chan);
+
+#define AHUB_MUX(name, ctrl) \
+	SND_SOC_DAPM_MUX(name, SND_SOC_NOPM, 0, 0, &ctrl)
+
+#define AHUB_MUX_DAM0(name, ctrl, ch) \
+	SND_SOC_DAPM_MUX(name, \
+	SUNXI_AHUB_DAM_CTL(0), DAM_CTL_RX0EN+ch, 0, &ctrl)
+
+#define AHUB_MUX_DAM1(name, ctrl, ch) \
+	SND_SOC_DAPM_MUX(name, \
+	SUNXI_AHUB_DAM_CTL(1), DAM_CTL_RX0EN+ch, 0, &ctrl)
+
+/*three apbif dev group */
+APBIF_RX_MUX_CONTROLS(0)
+APBIF_RX_MUX_CONTROLS(1)
+APBIF_RX_MUX_CONTROLS(2)
+/* four i2s dev group */
+I2S_RX_MUX_CONTROLS(0)
+I2S_RX_MUX_CONTROLS(1)
+I2S_RX_MUX_CONTROLS(2)
+I2S_RX_MUX_CONTROLS(3)
+/* two digital audio mux & three chan dev group */
+DAM0_RX_MUX_CONTROLS(0)
+DAM0_RX_MUX_CONTROLS(1)
+DAM0_RX_MUX_CONTROLS(2)
+DAM1_RX_MUX_CONTROLS(0)
+DAM1_RX_MUX_CONTROLS(1)
+DAM1_RX_MUX_CONTROLS(2)
+
+struct str_conv {
+	char *str;
+	int regbit;
+};
+
+/* I2S module usage control by cpu_dai */
+static struct str_conv mod_str_conv[] = {
+	{"APBIF0 DAC", 31},
+	{"APBIF1 DAC", 30},
+	{"APBIF2 DAC", 29},
+	{"APBIF0 ADC", 27},
+	{"APBIF1 ADC", 26},
+	{"APBIF2 ADC", 25},
+	{"DAM0 Mixer", 15},
+	{"DAM1 Mixer", 14},
+};
+
+static int sunxi_ahub_mod_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct sunxi_ahub_priv *sunxi_ahub =
+			snd_soc_codec_get_drvdata(snd_soc_dapm_to_codec(w->dapm));
+	int reg_bit = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mod_str_conv); i++)
+		if (!strncmp(mod_str_conv[i].str, w->name,
+					strlen(mod_str_conv[i].str))) {
+			reg_bit = mod_str_conv[i].regbit;
+			break;
+		}
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_RST,
+				(0x1<<reg_bit), (0x1<<reg_bit));
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_GAT,
+				(0x1<<reg_bit), (0x1<<reg_bit));
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_GAT,
+				(0x1<<reg_bit), (0x0<<reg_bit));
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_RST,
+				(0x1<<reg_bit), (0x0<<reg_bit));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+
+static const struct snd_soc_dapm_widget sunxi_ahub_codec_dapm_widgets[] = {
+	/* APBIF module output & input widgets */
+	SND_SOC_DAPM_AIF_IN_E("APBIF0 DAC", "AIF1 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF0 ADC", "AIF1 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("APBIF1 DAC", "AIF2 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF1 ADC", "AIF2 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("APBIF2 DAC", "AIF3 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF2 ADC", "AIF3 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	AHUB_MUX("APBIF0 Src Select", apbif0_rx_mux),
+	AHUB_MUX("APBIF1 Src Select", apbif1_rx_mux),
+	AHUB_MUX("APBIF2 Src Select", apbif2_rx_mux),
+	AHUB_MUX("I2S0 Src Select", i2s0_rx_mux),
+	AHUB_MUX("I2S1 Src Select", i2s1_rx_mux),
+	AHUB_MUX("I2S2 Src Select", i2s2_rx_mux),
+	AHUB_MUX("I2S3 Src Select", i2s3_rx_mux),
+	AHUB_MUX_DAM0("DAM0Chan0 Src Select", dam0chan0_rx_mux, 0),
+	AHUB_MUX_DAM0("DAM0Chan1 Src Select", dam0chan1_rx_mux, 1),
+	AHUB_MUX_DAM0("DAM0Chan2 Src Select", dam0chan2_rx_mux, 2),
+	AHUB_MUX_DAM1("DAM1Chan0 Src Select", dam1chan0_rx_mux, 0),
+	AHUB_MUX_DAM1("DAM1Chan1 Src Select", dam1chan1_rx_mux, 1),
+	AHUB_MUX_DAM1("DAM1Chan2 Src Select", dam1chan2_rx_mux, 2),
+
+
+	SND_SOC_DAPM_OUT_DRV_E("DAM0 Mixer", SUNXI_AHUB_DAM_CTL(0),
+			DAM_CTL_TXEN, 0, NULL, 0, sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_OUT_DRV_E("DAM1 Mixer", SUNXI_AHUB_DAM_CTL(1),
+			DAM_CTL_TXEN, 0, NULL, 0, sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_INPUT("I2S0 DAC"),
+	SND_SOC_DAPM_INPUT("I2S1 DAC"),
+	SND_SOC_DAPM_INPUT("I2S2 DAC"),
+	SND_SOC_DAPM_INPUT("I2S3 DAC"),
+	SND_SOC_DAPM_OUTPUT("I2S0 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S1 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S2 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S3 ADC"),
+	/*build some virt widget for dam*/
+	SND_SOC_DAPM_OUTPUT("DAM0 OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DAM1 OUTPUT"),
+	SND_SOC_DAPM_INPUT("DAM0 INPUT"),
+	SND_SOC_DAPM_INPUT("DAM1 INPUT"),
+};
+
+static const struct snd_soc_dapm_route sunxi_ahub_codec_dapm_routes[] = {
+	/* APBIF0 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	/* APBIF1 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	/* APBIF2 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	/* I2S0 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"APBIF1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"APBIF2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S3 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM0Chan0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM0Chan1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM0Chan2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	/* I2S1 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"APBIF1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"APBIF2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S3 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM0Chan0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM0Chan1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM0Chan2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	/* I2S2 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"APBIF1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"APBIF2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S3 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM0Chan0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM0Chan1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM0Chan2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	/* I2S3 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"APBIF1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"APBIF2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S3 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM0Chan0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM0Chan1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM0Chan2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+#if 0
+	/* DAM0 Audio Mixer output route */
+	{"DAM0 Mixer", "NULL", "DAM0Chan0 Src Select"},
+	{"DAM0 Mixer", "NULL", "DAM0Chan1 Src Select"},
+	{"DAM0 Mixer", "NULL", "DAM0Chan2 Src Select"},
+	{"DAM1 Mixer", "NULL", "DAM1Chan0 Src Select"},
+	{"DAM1 Mixer", "NULL", "DAM1Chan1 Src Select"},
+	{"DAM1 Mixer", "NULL", "DAM1Chan2 Src Select"},
+#endif
+	/* DAM0 Audio Mixer output route */
+	{"APBIF0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"APBIF1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"APBIF2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S3 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM0Chan0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM0Chan1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM0Chan2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	/* DAM1 Audio Mixer output route */
+	{"APBIF0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"APBIF1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"APBIF2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S3 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM0Chan0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM0Chan1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM0Chan2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+
+	/* Mixer to APBIF Capture */
+	{"APBIF0 ADC", "NULL", "APBIF0 Src Select"},
+	{"APBIF1 ADC", "NULL", "APBIF1 Src Select"},
+	{"APBIF2 ADC", "NULL", "APBIF2 Src Select"},
+	/* Mixer to I2S OUT(as ahub side says) */
+	{"I2S0 ADC", "NULL", "I2S0 Src Select"},
+	{"I2S1 ADC", "NULL", "I2S1 Src Select"},
+	{"I2S2 ADC", "NULL", "I2S2 Src Select"},
+	{"I2S3 ADC", "NULL", "I2S3 Src Select"},
+	{"DAM0 Mixer", "NULL", "DAM0 INPUT"},
+	{"DAM1 Mixer", "NULL", "DAM1 INPUT"},
+	{"DAM0 OUTPUT", "NULL", "DAM0Chan0 Src Select"},
+	{"DAM0 OUTPUT", "NULL", "DAM0Chan1 Src Select"},
+	{"DAM0 OUTPUT", "NULL", "DAM0Chan1 Src Select"},
+
+	{"DAM1 OUTPUT", "NULL", "DAM1Chan0 Src Select"},
+	{"DAM1 OUTPUT", "NULL", "DAM1Chan1 Src Select"},
+	{"DAM1 OUTPUT", "NULL", "DAM1Chan1 Src Select"},
+};
+
+static void sunxi_ahub_codec_init(struct snd_soc_codec *codec)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_codec_get_drvdata(codec);
+	int i;
+
+	/* if we used the audio hub, so we default setting HDMI clk from ahub */
+	regmap_write(sunxi_ahub->regmap, SUNXI_AHUB_CTL, 1<<HDMI_SRC_SEL);
+
+	for (i = 0; i < 2; i++) {
+		/* setting audio hub default channel line configure */
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL0(i), 0x01110000);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL1(i), 0x03330222);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL2(i), 0x05550444);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL3(i), 0x07770666);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL4(i), 0x09990888);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL5(i), 0x0bbb0aaa);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL6(i), 0x0ddd0ccc);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL7(i), 0x0fff0eee);
+		/* setting default audio hub volume */
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL0(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL1(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL2(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL3(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL4(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL5(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL6(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL7(i), 0x01110111);
+	}
+}
+
+static int sunxi_ahub_codec_dai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_priv *sunxi_ahub =
+				snd_soc_codec_get_drvdata(dai->codec);
+	struct sunxi_hdmi_priv *sunxi_hdmi =
+				snd_soc_card_get_drvdata(dai->component->card);
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* special handle for HDMI rawdata mode */
+			if (sunxi_hdmi->hdmi_format > 1) {
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (7<<APBIF_TX_WS));
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_TXIM), (0<<APBIF_TX_TXIM));
+			} else {
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (3<<APBIF_TX_WS));
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+			}
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (3<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (5<<APBIF_TX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (5<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S32_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (7<<APBIF_TX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (7<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	default:
+		dev_info(sunxi_ahub->dev, "unsupport format");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(sunxi_ahub->regmap,
+			SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+			(0xf<<APBIF_TX_CHAN_NUM),
+			((params_channels(params)-1)<<APBIF_TX_CHAN_NUM));
+	else
+		regmap_update_bits(sunxi_ahub->regmap,
+			SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+			(0xf<<APBIF_RX_CHAN_NUM),
+			((params_channels(params)-1)<<APBIF_RX_CHAN_NUM));
+
+	/*
+	 * we should using this as the demand chans, but we can't distinguish
+	 * stream type(playback or capture). so we can't make it done on demand,
+	 * so we just make all dam rx channel number as the sunxi_ahub->channel.
+	 */
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX0_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX0_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX1_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX1_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX2_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX2_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_TX_NUM),
+			((params_channels(params)-1)<<DAM_CTL_TX_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX0_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX0_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX1_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX1_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX2_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX2_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_TX_NUM),
+			((params_channels(params)-1)<<DAM_CTL_TX_NUM));
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_FTX), (1<<APBIF_TX_FTX));
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_dai_get_drvdata(dai);
+
+	if (clk_set_rate(sunxi_ahub->pllclk, freq)) {
+		dev_err(sunxi_ahub->dev, "set pllclk rate failed\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_FTX), (1<<APBIF_TX_FTX));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TX_IRQ_STA(dai->id),
+				(1<<APBIF_TX_OV_PEND|1<<APBIF_TX_EM_PEND));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CNT(dai->id), 0);
+	} else {
+		regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(1<<APBIF_RX_FRX), (1<<APBIF_RX_FRX));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RX_IRQ_STA(dai->id),
+				(1<<APBIF_RX_UV_PEND|1<<APBIF_RX_AV_PEND));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CNT(dai->id), 0);
+	}
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_ahub_codec_dai_ops = {
+	.hw_params	= sunxi_ahub_codec_dai_hw_params,
+	.set_sysclk	= sunxi_ahub_codec_dai_set_sysclk,
+	.trigger	= sunxi_ahub_codec_dai_trigger,
+	.prepare	= sunxi_ahub_codec_dai_prepare,
+};
+
+/* ahub codec dai */
+static struct snd_soc_dai_driver sunxi_ahub_codec_dais[] = {
+	{
+		.name = "sunxi-ahub-aif1",
+		.id = 0,
+		.playback = {
+			.stream_name = "AIF1 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF1 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		 },
+		.ops = &sunxi_ahub_codec_dai_ops,
+	},
+	{
+		.name = "sunxi-ahub-aif2",
+		.id = 1,
+		.playback = {
+			.stream_name = "AIF2 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF2 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_ahub_codec_dai_ops,
+	},
+	{
+		.name = "sunxi-ahub-aif3",
+		.id = 2,
+		.playback = {
+			.stream_name = "AIF3 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF3 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		 },
+		.ops = &sunxi_ahub_codec_dai_ops,
+	}
+};
+
+static int sunxi_ahub_codec_probe(struct snd_soc_codec *codec)
+{
+	sunxi_ahub_codec_init(codec);
+	return 0;
+}
+
+static int sunxi_ahub_codec_suspend(struct snd_soc_codec *codec)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_codec_get_drvdata(codec);
+	pr_debug("Enter %s\n", __func__);
+
+	clk_disable_unprepare(sunxi_ahub->moduleclk);
+	clk_disable_unprepare(sunxi_ahub->pllclk);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_resume(struct snd_soc_codec *codec)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_codec_get_drvdata(codec);
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (clk_prepare_enable(sunxi_ahub->pllclk)) {
+		dev_err(sunxi_ahub->dev, "pllclk resume failed\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_ahub->moduleclk)) {
+		dev_err(sunxi_ahub->dev, "moduleclk resume failed\n");
+		return -EBUSY;
+	}
+
+	sunxi_ahub_codec_init(codec);
+	// sunxi_ahub_cpudai_init();
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_ahub_dev_sunxi = {
+	.probe = sunxi_ahub_codec_probe,
+	.suspend = sunxi_ahub_codec_suspend,
+	.resume = sunxi_ahub_codec_resume,
+	.ignore_pmdown_time = 1,
+	.component_driver.dapm_widgets = sunxi_ahub_codec_dapm_widgets,
+	.component_driver.num_dapm_widgets = ARRAY_SIZE(sunxi_ahub_codec_dapm_widgets),
+	.component_driver.dapm_routes = sunxi_ahub_codec_dapm_routes,
+	.component_driver.num_dapm_routes = ARRAY_SIZE(sunxi_ahub_codec_dapm_routes),
+};
+
+static int sunxi_ahub_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	dev_set_drvdata(&pdev->dev, sunxi_ahub);
+	sunxi_ahub->dev = &pdev->dev;
+
+	sunxi_ahub->pllclk = of_clk_get(np, 0);
+	if (IS_ERR_OR_NULL(sunxi_ahub->pllclk)) {
+		dev_err(&pdev->dev, "pllclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub->pllclk);
+		goto err_node_put;
+	}
+
+	sunxi_ahub->moduleclk = of_clk_get(np, 1);
+	if (IS_ERR_OR_NULL(sunxi_ahub->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub->moduleclk);
+		goto err_pllclk_put;
+	}
+
+	if (clk_set_parent(sunxi_ahub->moduleclk, sunxi_ahub->pllclk)) {
+		dev_err(&pdev->dev, "set parent of moduleclk to pllclk fail\n");
+		ret = -EBUSY;
+		goto err_moduleclk_put;
+	}
+	clk_prepare_enable(sunxi_ahub->pllclk);
+	clk_prepare_enable(sunxi_ahub->moduleclk);
+
+	sunxi_ahub->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_moduleclk_put;
+	}
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_ahub_dev_sunxi,
+				sunxi_ahub_codec_dais,
+				ARRAY_SIZE(sunxi_ahub_codec_dais));
+	if (ret) {
+		dev_err(&pdev->dev, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_moduleclk_put;
+	}
+
+	return 0;
+
+err_moduleclk_put:
+	clk_put(sunxi_ahub->moduleclk);
+err_pllclk_put:
+	clk_put(sunxi_ahub->pllclk);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_ahub_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	clk_put(sunxi_ahub->moduleclk);
+	clk_put(sunxi_ahub->pllclk);
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub", },
+	{},
+};
+
+static struct platform_driver sunxi_ahub_driver = {
+	.probe = sunxi_ahub_dev_probe,
+	.remove = __exit_p(sunxi_ahub_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_of_match,
+	},
+};
+
+module_platform_driver(sunxi_ahub_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub Codec ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-ahub");
diff --git a/sound/soc/sunxi/sunxi_ahub.h b/sound/soc/sunxi/sunxi_ahub.h
new file mode 100644
index 000000000..345cab658
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_ahub.h
@@ -0,0 +1,291 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub.h
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_AHUB_H_
+#define _SUNXI_AHUB_H_
+
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+
+/* SUNXI Audio Hub registers list */
+#define SUNXI_AHUB_CTL		0x00
+#define SUNXI_AHUB_VER		0x04
+#define SUNXI_AHUB_RST		0x08
+#define SUNXI_AHUB_GAT		0x0c
+/* Left blank */
+#define SUNXI_AHUB_APBIF_TX_CTL(n)		(0x10 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_CTL(n)		(0x14 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_STA(n)		(0x18 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_TXFIFO_CTL(n)		(0x20 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_STA(n)		(0x24 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_TXFIFO(n)		(0x30 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_CNT(n)		(0x34 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RX_CTL(n)		(0x100 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_CTL(n)		(0x104 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_STA(n)		(0x108 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RXFIFO_CTL(n)		(0x110 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_STA(n)		(0x114 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CONT(n)		(0x118 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RXFIFO(n)		(0x120 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CNT(n)		(0x124 + ((n) * 0x30))
+
+#define SUNXI_AHUB_I2S_CTL(n)			(0x200 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT0(n)			(0x204 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT1(n)			(0x208 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CLKD(n)			(0x20c + ((n) << 8))
+/* Left Blank */
+#define SUNXI_AHUB_I2S_RXCONT(n)		(0x220 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CHCFG(n)			(0x224 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_CTL(n)		(0x228 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_STA(n)		(0x22C + ((n) << 8))
+#define SUNXI_AHUB_I2S_OUT_SLOT0(n)		(0x230 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT1(n)		(0x230 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT2(n)		(0x230 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT3(n)		(0x230 + ((n) << 8) + (3 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH0MAP0(n)		(0x234 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH1MAP0(n)		(0x234 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH2MAP0(n)		(0x234 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH3MAP0(n)		(0x234 + ((n) << 8) + (3 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH0MAP1(n)		(0x238 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH1MAP1(n)		(0x238 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH2MAP1(n)		(0x238 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH3MAP1(n)		(0x238 + ((n) << 8) + (3 << 4))
+
+
+
+
+/* Left Blank */
+#define SUNXI_AHUB_I2S_IN_SLOT(n)		(0x270 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP0(n)		(0x274 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP1(n)		(0x278 + ((n) << 8))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_CTL(n)			(0xA00 + ((n) << 7))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_RX0_SRC(n)		(0xA10 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX1_SRC(n)		(0xA14 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX2_SRC(n)		(0xA18 + ((n) << 7))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_MIX_CTL0(n)		(0xA30 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL1(n)		(0xA34 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL2(n)		(0xA38 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL3(n)		(0xA3C + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL4(n)		(0xA40 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL5(n)		(0xA44 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL6(n)		(0xA48 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL7(n)		(0xA4C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL0(n)		(0xA50 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL1(n)		(0xA54 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL2(n)		(0xA58 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL3(n)		(0xA5C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL4(n)		(0xA60 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL5(n)		(0xA64 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL6(n)		(0xA68 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL7(n)		(0xA6C + ((n) << 7))
+
+/* SUNXI_AHUB_CTL */
+#define HDMI_SRC_SEL		0x04
+
+/* SUNXI_AHUB_RST */
+#define APBIF_TXDIF0_RST	31
+#define APBIF_TXDIF1_RST	30
+#define APBIF_TXDIF2_RST	29
+#define APBIF_RXDIF0_RST	27
+#define APBIF_RXDIF1_RST	26
+#define APBIF_RXDIF2_RST	25
+#define I2S0_RST		23
+#define I2S1_RST		22
+#define I2S2_RST		21
+#define I2S3_RST		20
+#define DAM0_RST		15
+#define DAM1_RST		14
+
+/* SUNXI_AHUB_GAT */
+#define APBIF_TXDIF0_GAT	31
+#define APBIF_TXDIF1_GAT	30
+#define APBIF_TXDIF2_GAT	29
+#define APBIF_RXDIF0_GAT	27
+#define APBIF_RXDIF1_GAT	26
+#define APBIF_RXDIF2_GAT	25
+#define I2S0_GAT		23
+#define I2S1_GAT		22
+#define I2S2_GAT		21
+#define I2S3_GAT		20
+#define DAM0_GAT		15
+#define DAM1_GAT		14
+
+/* SUNXI_AHUB_APBIF_TX_CTL */
+#define APBIF_TX_WS		16
+#define APBIF_TX_CHAN_NUM	8
+#define	APBIF_TX_START		4
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_CTL */
+#define APBIF_TX_DRQ		3
+#define APBIF_TX_OVEN		1
+#define APBIF_TX_EMEN		0
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_STA */
+#define APBIF_TX_OV_PEND	1
+#define APBIF_TX_EM_PEND	0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_CTL */
+#define APBIF_TX_FTX		12
+#define APBIF_TX_LEVEL		4
+#define APBIF_TX_TXIM		0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_STA */
+#define APBIF_TX_EMPTY		8
+#define APBIF_TX_EMCNT		0
+
+/* SUNXI_AHUB_APBIF_RX_CTL */
+#define APBIF_RX_WS		16
+#define APBIF_RX_CHAN_NUM	8
+#define	APBIF_RX_START		4
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_CTL */
+#define APBIF_RX_DRQ		3
+#define APBIF_RX_UVEN		2
+#define APBIF_RX_AVEN		0
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_STA */
+#define APBIF_RX_UV_PEND	1
+#define APBIF_RX_AV_PEND	0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CTL */
+#define APBIF_RX_FRX		12
+#define APBIF_RX_LEVEL		4
+#define APBIF_RX_RXOM		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_STA */
+#define APBIF_RX_AVAIL		8
+#define APBIF_RX_AVCNT		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CONT */
+#define APBIF_RX_APBIF_TXDIF0		31
+#define APBIF_RX_APBIF_TXDIF1		30
+#define APBIF_RX_APBIF_TXDIF2		29
+#define APBIF_RX_I2S0_TXDIF		27
+#define APBIF_RX_I2S1_TXDIF		26
+#define APBIF_RX_I2S2_TXDIF		25
+#define APBIF_RX_I2S3_TXDIF		23
+#define APBIF_RX_DAM0_TXDIF		19
+#define APBIF_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CTL */
+#define I2S_CTL_CLK_OUT			18
+#define I2S_CTL_SDO3_EN			11
+#define I2S_CTL_SDO2_EN			10
+#define I2S_CTL_SDO1_EN			9
+#define I2S_CTL_SDO0_EN			8
+#define I2S_CTL_OUT_MUTE		6
+#define I2S_CTL_MODE			4
+#define I2S_CTL_LOOP			3
+#define I2S_CTL_TXEN			2
+#define I2S_CTL_RXEN			1
+#define I2S_CTL_GEN			0
+
+/* SUNXI_AHUB_I2S_FMT0 */
+#define I2S_FMT0_LRCK_WIDTH		30
+#define I2S_FMT0_LRCK_POLARITY		19
+#define I2S_FMT0_LRCK_PERIOD		8
+#define I2S_FMT0_BCLK_POLARITY		7
+#define I2S_FMT0_SR			4
+#define I2S_FMT0_EDGE			3
+#define I2S_FMT0_SW			0
+
+/* SUNXI_AHUB_I2S_FMT1 */
+#define I2S_FMT1_RX_LSB			7
+#define I2S_FMT1_TX_LSB			6
+#define I2S_FMT1_EXT			4
+#define I2S_FMT1_RX_PDM			2
+#define I2S_FMT1_TX_PDM			0
+
+/* SUNXI_AHUB_I2S_CLKD */
+#define I2S_CLKD_MCLK			8
+#define	I2S_CLKD_BCLKDIV		4
+#define I2S_CLKD_MCLKDIV		0
+
+/* SUNXI_AHUB_I2S_RXCONT */
+#define I2S_RX_APBIF_TXDIF0		31
+#define I2S_RX_APBIF_TXDIF1		30
+#define I2S_RX_APBIF_TXDIF2		29
+#define I2S_RX_I2S0_TXDIF		27
+#define I2S_RX_I2S1_TXDIF		26
+#define I2S_RX_I2S2_TXDIF		25
+#define I2S_RX_I2S3_TXDIF		23
+#define I2S_RX_DAM0_TXDIF		19
+#define I2S_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CHCFG */
+#define I2S_CHCFG_HIZ			9
+#define	I2S_CHCFG_TX_STATE		8
+#define I2S_CHCFG_RX_CHANNUM		4
+#define I2S_CHCFG_TX_CHANNUM		0
+
+/* SUNXI_AHUB_I2S_IRQ_CTL */
+#define I2S_IRQ_RXOV_EN			1
+#define I2S_IRQ_TXUV_EN			0
+
+/* SUNXI_AHUB_I2S_IRQ_STA */
+#define I2S_IRQ_RXOV_PEND		1
+#define I2S_IRQ_TXUV_PEND		0
+
+/* SUNXI_AHUB_I2S_OUT_SLOT */
+#define I2S_OUT_OFFSET			20
+#define I2S_OUT_SLOT_NUM		16
+#define I2S_OUT_SLOT_EN			0
+
+/* SUNXI_AHUB_I2S_IN_SLOT */
+#define I2S_IN_OFFSET			20
+#define I2S_IN_SLOT_NUM			16
+
+/* SUNXI_AHUB_DAM_CTL */
+#define DAM_CTL_RX2_NUM			24
+#define DAM_CTL_RX1_NUM			20
+#define DAM_CTL_RX0_NUM			16
+#define DAM_CTL_TX_NUM			8
+#define DAM_CTL_RX2EN			6
+#define DAM_CTL_RX1EN			5
+#define DAM_CTL_RX0EN			4
+#define DAM_CTL_TXEN			0
+
+/* SUNXI_AHUB_DAM_RX##chan##_SRC */
+#define DAM_RX_APBIF_TXDIF0		31
+#define DAM_RX_APBIF_TXDIF1		30
+#define DAM_RX_APBIF_TXDIF2		29
+#define DAM_RX_I2S0_TXDIF		27
+#define DAM_RX_I2S1_TXDIF		26
+#define DAM_RX_I2S2_TXDIF		25
+#define DAM_RX_I2S3_TXDIF		23
+#define DAM_RX_DAM0_TXDIF		19
+#define DAM_RX_DAM1_TXDIF		15
+
+/* For sun50iw6, if others should redefine */
+#define SUNXI_AHUB_HDMI_ID			1
+
+extern struct regmap *sunxi_ahub_regmap_init(struct platform_device *pdev);
+extern unsigned int sunxi_ahub_read(unsigned int reg);
+extern int sunxi_ahub_update_bits(unsigned int reg, unsigned int mask,
+				unsigned int val);
+extern int sunxi_ahub_cpudai_init(void);
+
+/* used for sunxi netlink to auto open others card */
+extern void sunxi_netlink_printd(const char *fmt, ...);
+#endif
diff --git a/sound/soc/sunxi/sunxi_ahub_cpudai.c b/sound/soc/sunxi/sunxi_ahub_cpudai.c
new file mode 100644
index 000000000..fb975a7a3
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_ahub_cpudai.c
@@ -0,0 +1,484 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub_cpudai.c
+ * (C) Copyright 2014-2018
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/dma/sunxi-dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "sunxi_dma.h"
+#include "sunxi_ahub.h"
+
+#define DRV_NAME "sunxi-ahub-cpudai"
+
+struct sunxi_ahub_cpudai_priv {
+	unsigned int id;
+	int karaoke_mode;
+	struct regmap *regmap;
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+};
+
+static int startup_playback_cnt;
+static int startup_capture_cnt;
+static int karaoke_cnt;
+
+int sunxi_ahub_cpudai_init(void)
+{
+	startup_playback_cnt = 0;
+	startup_capture_cnt = 0;
+	karaoke_cnt = 0;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_cpudai_init);
+
+
+static int sunxi_ahub_i2s_playback_route_enable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	int i, reg_bit;
+	unsigned int reg_val;
+
+	/* first check it's on karaoke mode? */
+	reg_val = sunxi_ahub_read(SUNXI_AHUB_DAM_RX0_SRC(0));
+	if (!reg_val) {
+		reg_val = sunxi_ahub_read(
+				SUNXI_AHUB_DAM_RX1_SRC(0));
+		if (!reg_val)
+			goto no_karaook_handle;
+	}
+	for (i = 0; i < 4; i++) {
+		reg_val = sunxi_ahub_read(
+				SUNXI_AHUB_I2S_RXCONT(i));
+		if (reg_val & (1<<19)) {
+			/* I2S0...HDMI...I2S2...CVBS... */
+			reg_bit = 23 - i;
+			/* setting the rst & gating register for I2S module */
+			sunxi_ahub_update_bits(
+					SUNXI_AHUB_RST,
+					(1<<reg_bit), (1<<reg_bit));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_GAT,
+				(1<<reg_bit), (1<<reg_bit));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_I2S_CTL(i),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		}
+	}
+	sunxi_ahub_cpudai->karaoke_mode = 1;
+	karaoke_cnt++;
+	return 0;
+
+no_karaook_handle:
+	switch (sunxi_ahub_cpudai->id) {
+	case 0:
+		/* operation HDMI I2S module */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S1_RST), (1<<I2S1_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S1_GAT), (1<<I2S1_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	case 1:
+		/* operation CVBS module */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S3_RST), (1<<I2S3_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S3_GAT), (1<<I2S3_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	case 2:
+		/* operation I2S2 for bluetooth */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S2_RST), (1<<I2S2_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S2_GAT), (1<<I2S2_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	default:
+		break;
+	}
+	sunxi_ahub_cpudai->karaoke_mode = 0;
+	return 0;
+}
+
+static int sunxi_ahub_i2s_playback_route_disable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	unsigned int reg_val;
+	int i;
+
+	if (sunxi_ahub_cpudai->karaoke_mode) {
+		if (--karaoke_cnt == 0) {
+			for (i = 0; i < 4; i++) {
+				reg_val = sunxi_ahub_read(
+					SUNXI_AHUB_I2S_CTL(i));
+				if (reg_val & (1 << I2S_CTL_TXEN))
+					/* I2S0...HDMI...I2S2...CVBS... */
+					sunxi_ahub_update_bits(
+						SUNXI_AHUB_I2S_CTL(i),
+						(1<<I2S_CTL_TXEN),
+						(0<<I2S_CTL_TXEN));
+			}
+		}
+	} else {
+		switch (sunxi_ahub_cpudai->id) {
+		case 0:
+			/* operation HDMI I2S module */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		case 1:
+			/* operation CVBS module */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		case 2:
+			/* operation I2S2 for bluetooth */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		default:
+			break;
+		}
+	}
+	return 0;
+}
+
+
+static int sunxi_ahub_i2s_capture_route_enable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	/* HDMI just not support capture */
+	int i2s0_cap_bit = 27;
+	int i2s2_cap_bit = 25;
+	int i2s3_cap_bit = 23;
+	unsigned int reg_val;
+
+	reg_val = sunxi_ahub_read(
+		SUNXI_AHUB_APBIF_RXFIFO_CONT(sunxi_ahub_cpudai->id));
+	if (reg_val == (1<<i2s0_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S0_RST), (1<<I2S0_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S0_GAT), (1<<I2S0_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+	}
+
+	if (reg_val == (1<<i2s2_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S2_RST), (1<<I2S2_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S2_GAT), (1<<I2S2_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+	}
+
+	if (reg_val == (1<<i2s3_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S3_RST), (1<<I2S3_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S3_GAT), (1<<I2S3_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+	}
+	return 0;
+}
+
+static int sunxi_ahub_i2s_capture_route_disable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	/* HDMI just not support capture */
+	int i2s0_cap_bit = 27;
+	int i2s2_cap_bit = 25;
+	int i2s3_cap_bit = 23;
+	unsigned int reg_val;
+
+	reg_val = sunxi_ahub_read(
+		SUNXI_AHUB_APBIF_RXFIFO_CONT(sunxi_ahub_cpudai->id));
+	if (reg_val == (1<<i2s0_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+	}
+
+	if (reg_val == (1<<i2s2_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+	}
+
+	if (reg_val == (1<<i2s3_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+	}
+	return 0;
+}
+
+static int sunxi_ahub_cpudai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_ahub_cpudai->playback_dma_param);
+	else
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_ahub_cpudai->capture_dma_param);
+
+	return 0;
+}
+
+static int sunxi_ahub_cpudai_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					snd_soc_dai_get_drvdata(dai);
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (startup_playback_cnt++ == 0)
+				sunxi_ahub_i2s_playback_route_enable(
+						sunxi_ahub_cpudai);
+			mdelay(1);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_CTL(sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_START), (1<<APBIF_TX_START));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_IRQ_CTL(
+					sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_DRQ), (1<<APBIF_TX_DRQ));
+			if (startup_playback_cnt++ > 1)
+				sunxi_ahub_i2s_playback_route_enable(
+						sunxi_ahub_cpudai);
+		} else {
+			if (startup_capture_cnt++ == 0) {
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_START),
+					(1<<APBIF_RX_START));
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_IRQ_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_DRQ),
+					(1<<APBIF_RX_DRQ));
+			}
+			if (startup_capture_cnt++ > 0)
+				sunxi_ahub_i2s_capture_route_enable(
+						sunxi_ahub_cpudai);
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_i2s_playback_route_disable(
+				sunxi_ahub_cpudai);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_IRQ_CTL(
+				sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_DRQ), (0<<APBIF_TX_DRQ));
+			mdelay(2);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_CTL(sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_START), (0<<APBIF_TX_START));
+		} else {
+			sunxi_ahub_i2s_capture_route_disable(
+					sunxi_ahub_cpudai);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct snd_soc_dai_ops sunxi_ahub_cpudai_dai_ops = {
+	.startup = sunxi_ahub_cpudai_startup,
+	.trigger = sunxi_ahub_cpudai_trigger,
+};
+
+static struct snd_soc_dai_driver sunxi_ahub_cpudai_dai = {
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops	= &sunxi_ahub_cpudai_dai_ops,
+
+};
+
+static const struct snd_soc_component_driver sunxi_ahub_cpudai_component = {
+	.name		= DRV_NAME,
+};
+static const struct of_device_id sunxi_ahub_cpudai_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-cpudai", },
+	{},
+};
+
+static int  sunxi_ahub_cpudai_dev_probe(struct platform_device *pdev)
+{
+	struct resource res;
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+	sunxi_ahub_cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_ahub_cpudai_priv), GFP_KERNEL);
+	if (!sunxi_ahub_cpudai) {
+		dev_err(&pdev->dev, "Can't allocate sunxi_cpudai\n");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_ahub_cpudai);
+
+	ret = of_property_read_u32(np, "id", &temp_val);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "id configuration missing or invalid\n");
+		goto err_devm_kfree;
+	} else {
+		sunxi_ahub_cpudai->id = temp_val;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't parse device node resource\n");
+		ret = -ENODEV;
+		goto err_devm_kfree;
+	}
+
+	switch (sunxi_ahub_cpudai->id) {
+	case 0:
+		sunxi_ahub_cpudai->playback_dma_param.dma_drq_type_num =
+							DRQDST_AHUB0_TX;
+		sunxi_ahub_cpudai->capture_dma_param.dma_drq_type_num =
+							DRQSRC_AHUB0_RX;
+		break;
+	case 1:
+		sunxi_ahub_cpudai->playback_dma_param.dma_drq_type_num =
+							DRQDST_AHUB1_TX;
+		sunxi_ahub_cpudai->capture_dma_param.dma_drq_type_num =
+							DRQSRC_AHUB1_RX;
+		break;
+	case 2:
+		sunxi_ahub_cpudai->playback_dma_param.dma_drq_type_num =
+							DRQDST_AHUB2_TX;
+		sunxi_ahub_cpudai->capture_dma_param.dma_drq_type_num =
+							DRQSRC_AHUB2_RX;
+		break;
+	default:
+		dev_err(&pdev->dev, "ahub cpudai id invalid\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+	sunxi_ahub_cpudai->playback_dma_param.dma_addr =
+		res.start + SUNXI_AHUB_APBIF_TXFIFO(sunxi_ahub_cpudai->id);
+	sunxi_ahub_cpudai->playback_dma_param.dst_maxburst = 4;
+	sunxi_ahub_cpudai->playback_dma_param.src_maxburst = 4;
+
+	sunxi_ahub_cpudai->capture_dma_param.dma_addr =
+		res.start + SUNXI_AHUB_APBIF_RXFIFO(sunxi_ahub_cpudai->id);
+	sunxi_ahub_cpudai->capture_dma_param.src_maxburst = 4;
+	sunxi_ahub_cpudai->capture_dma_param.dst_maxburst = 4;
+
+	sunxi_ahub_cpudai->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub_cpudai->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_devm_kfree;
+	}
+	sunxi_ahub_cpudai_init();
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&sunxi_ahub_cpudai_component,
+			&sunxi_ahub_cpudai_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_devm_kfree;
+	}
+
+	ret = asoc_dma_platform_register(&pdev->dev,
+			SND_DMAENGINE_PCM_FLAG_NO_RESIDUE);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		goto err_unregister_component;
+	}
+
+	return 0;
+
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_ahub_cpudai);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_ahub_cpudai_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	devm_kfree(&pdev->dev, sunxi_ahub_cpudai);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_ahub_cpudai_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_cpudai_of_match,
+	},
+	.probe = sunxi_ahub_cpudai_dev_probe,
+	.remove = __exit_p(sunxi_ahub_cpudai_dev_remove),
+};
+
+module_platform_driver(sunxi_ahub_cpudai_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub cpudai ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi/sunxi_ahub_daudio.c b/sound/soc/sunxi/sunxi_ahub_daudio.c
new file mode 100644
index 000000000..79dd2d4ea
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_ahub_daudio.c
@@ -0,0 +1,1000 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub_daudio.c
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "sunxi_ahub.h"
+#include "sunxi_dma.h"
+
+#define DRV_NAME	"sunxi-ahub-daudio"
+
+struct sunxi_ahub_daudio_priv {
+	struct device *dev;
+	struct regmap *regmap;
+	struct clk *pllclk;
+	struct clk *moduleclk;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinstate;
+	struct pinctrl_state *pinstate_sleep;
+	struct snd_soc_dai_driver *cpudai;
+	char cpudai_name[20];
+	struct mutex mutex;
+	int used_cnt;
+	unsigned int pinconfig;
+	unsigned int frame_type;
+	unsigned int daudio_master;
+	unsigned int pcm_lrck_period;
+	unsigned int slot_width_select;
+	unsigned int audio_format;
+	unsigned int signal_inversion;
+	unsigned int tdm_config;
+	unsigned int tdm_num;
+	unsigned int mclk_div;
+};
+
+static int sunxi_ahub_daudio_global_enable(struct sunxi_ahub_daudio_priv
+		*sunxi_ahub_daudio, int enable, unsigned int id)
+{
+	if (enable) {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_SDO0_EN), (1<<I2S_CTL_SDO0_EN));
+		/* Special processing for HDMI hub playback module */
+		if (sunxi_ahub_daudio->tdm_num  == SUNXI_AHUB_HDMI_ID) {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO1_EN), (1<<I2S_CTL_SDO1_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO2_EN), (1<<I2S_CTL_SDO2_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO3_EN), (1<<I2S_CTL_SDO3_EN));
+		}
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_GEN), (1<<I2S_CTL_GEN));
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_GEN), (0<<I2S_CTL_GEN));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_SDO0_EN), (0<<I2S_CTL_SDO0_EN));
+		/* Special processing for HDMI hub playback module */
+		if (sunxi_ahub_daudio->tdm_num  == SUNXI_AHUB_HDMI_ID) {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO1_EN), (0<<I2S_CTL_SDO1_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO2_EN), (0<<I2S_CTL_SDO2_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO3_EN), (0<<I2S_CTL_SDO3_EN));
+		}
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_mclk_setting(struct sunxi_ahub_daudio_priv
+				*sunxi_ahub_daudio, unsigned int id)
+{
+	unsigned int mclk_div;
+
+	if (sunxi_ahub_daudio->mclk_div) {
+		switch (sunxi_ahub_daudio->mclk_div) {
+		case	1:
+			mclk_div = 1;
+			break;
+		case	2:
+			mclk_div = 2;
+			break;
+		case	4:
+			mclk_div = 3;
+			break;
+		case	6:
+			mclk_div = 4;
+			break;
+		case	8:
+			mclk_div = 5;
+			break;
+		case	12:
+			mclk_div = 6;
+			break;
+		case	16:
+			mclk_div = 7;
+			break;
+		case	24:
+			mclk_div = 8;
+			break;
+		case	32:
+			mclk_div = 9;
+			break;
+		case	48:
+			mclk_div = 10;
+			break;
+		case	64:
+			mclk_div = 11;
+			break;
+		case	96:
+			mclk_div = 12;
+			break;
+		case	128:
+			mclk_div = 13;
+			break;
+		case	176:
+			mclk_div = 14;
+			break;
+		case	192:
+			mclk_div = 15;
+			break;
+		default:
+			dev_err(sunxi_ahub_daudio->dev,
+					"unsupport  mclk_div\n");
+			return -EINVAL;
+		}
+		/* setting Mclk as external codec input clk */
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0xf<<I2S_CLKD_MCLKDIV),
+				(mclk_div<<I2S_CLKD_MCLKDIV));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0x1<<I2S_CLKD_MCLK), (1<<I2S_CLKD_MCLK));
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0x1<<I2S_CLKD_MCLK), (0<<I2S_CLKD_MCLK));
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_init_fmt(struct sunxi_ahub_daudio_priv
+		*sunxi_ahub_daudio, unsigned int fmt, unsigned int id)
+{
+	unsigned int offset, mode;
+	unsigned int lrck_polarity = 0;
+	unsigned int brck_polarity;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case	SND_SOC_DAIFMT_CBM_CFM:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_CLK_OUT), (0<<I2S_CTL_CLK_OUT));
+		break;
+	case	SND_SOC_DAIFMT_CBS_CFS:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_CLK_OUT), (1<<I2S_CTL_CLK_OUT));
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unknown maser/slave format\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+		offset = 1;
+		mode = 1;
+		break;
+	case	SND_SOC_DAIFMT_RIGHT_J:
+		offset = 0;
+		mode = 2;
+		break;
+	case	SND_SOC_DAIFMT_LEFT_J:
+		offset = 0;
+		mode = 1;
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+		offset = 1;
+		mode = 0;
+		break;
+	case	SND_SOC_DAIFMT_DSP_B:
+		offset = 0;
+		mode = 0;
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "format setting failed\n");
+		return -EINVAL;
+	}
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_CTL(id),
+			(0x3<<I2S_CTL_MODE), (mode<<I2S_CTL_MODE));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT0(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT1(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT2(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT3(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_SLOT(id),
+			(0x1<<I2S_IN_OFFSET), (offset<<I2S_IN_OFFSET));
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+	case	SND_SOC_DAIFMT_RIGHT_J:
+	case	SND_SOC_DAIFMT_LEFT_J:
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case	SND_SOC_DAIFMT_NB_NF:
+			lrck_polarity = 0;
+			brck_polarity = 0;
+			break;
+		case	SND_SOC_DAIFMT_NB_IF:
+			lrck_polarity = 1;
+			brck_polarity = 0;
+			break;
+		case	SND_SOC_DAIFMT_IB_NF:
+			lrck_polarity = 0;
+			brck_polarity = 1;
+			break;
+		case	SND_SOC_DAIFMT_IB_IF:
+			lrck_polarity = 1;
+			brck_polarity = 1;
+			break;
+		default:
+			dev_err(sunxi_ahub_daudio->dev,
+					"invert clk setting failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+	case	SND_SOC_DAIFMT_DSP_B:
+		/* frame inversion not valid for DSP modes */
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			lrck_polarity = 0;
+			brck_polarity = 0;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			lrck_polarity = 0;
+			brck_polarity = 1;
+			break;
+		default:
+			dev_err(sunxi_ahub_daudio->dev, "dai fmt invalid\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "format setting failed\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_LRCK_POLARITY),
+			(lrck_polarity<<I2S_FMT0_LRCK_POLARITY));
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_BCLK_POLARITY),
+			(brck_polarity<<I2S_FMT0_BCLK_POLARITY));
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				snd_soc_dai_get_drvdata(dai);
+
+	sunxi_ahub_daudio_init_fmt(sunxi_ahub_daudio, fmt,
+					(sunxi_ahub_daudio->tdm_num));
+	return 0;
+}
+
+
+static int sunxi_ahub_daudio_init(
+		struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio, int id)
+{
+	int ret;
+
+	sunxi_ahub_daudio_global_enable(sunxi_ahub_daudio, 1, id);
+
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH0MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH0MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH1MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH1MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH2MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH2MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH3MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH3MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP1(id), 0xFEDCBA98);
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_LRCK_WIDTH),
+			(sunxi_ahub_daudio->frame_type<<I2S_FMT0_LRCK_WIDTH));
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+		(0x1ff<<I2S_FMT0_LRCK_PERIOD),
+		((sunxi_ahub_daudio->pcm_lrck_period-1)<<I2S_FMT0_LRCK_PERIOD));
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+		(0x7<<I2S_FMT0_SW),
+		(((sunxi_ahub_daudio->slot_width_select>>2) - 1)<<I2S_FMT0_SW));
+
+	/*
+	 * MSB on the transmit format, always be first.
+	 * default using Linear-PCM, without no companding.
+	 * A-law<Eourpean standard> or U-law<US-Japan> not working ok.
+	 */
+	regmap_write(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT1(id), 0x30);
+
+	/* default setting the daudio fmt */
+	sunxi_ahub_daudio_init_fmt(sunxi_ahub_daudio,
+		(sunxi_ahub_daudio->audio_format
+		| (sunxi_ahub_daudio->signal_inversion<<8)
+		| (sunxi_ahub_daudio->daudio_master<<12)), id);
+
+	sunxi_ahub_daudio_mclk_setting(sunxi_ahub_daudio, id);
+
+	if (sunxi_ahub_daudio->pinconfig) {
+		sunxi_ahub_daudio->pinctrl =
+				devm_pinctrl_get(sunxi_ahub_daudio->dev);
+		if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pinctrl)) {
+			dev_err(sunxi_ahub_daudio->dev, "pinctrl get failed\n");
+			return -ENODEV;
+		}
+	}
+
+	if (sunxi_ahub_daudio->pinconfig) {
+		sunxi_ahub_daudio->pinstate =
+			pinctrl_lookup_state(sunxi_ahub_daudio->pinctrl,
+					"default");
+		if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pinstate)) {
+			dev_err(sunxi_ahub_daudio->dev,
+					"pinctrl default state get failed\n");
+			return -ENODEV;
+		}
+		sunxi_ahub_daudio->pinstate_sleep =
+			pinctrl_lookup_state(sunxi_ahub_daudio->pinctrl,
+					"sleep");
+		if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pinstate_sleep)) {
+			dev_err(sunxi_ahub_daudio->dev,
+					"pinctrl sleep state get failed\n");
+			return -ENODEV;
+		}
+		ret = pinctrl_select_state(sunxi_ahub_daudio->pinctrl,
+						sunxi_ahub_daudio->pinstate);
+		if (ret) {
+			dev_warn(sunxi_ahub_daudio->dev,
+					"select default state failed\n");
+			return -EBUSY;
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	struct sunxi_hdmi_priv *sunxi_hdmi =
+				snd_soc_card_get_drvdata(dai->component->card);
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		/*
+		 * Special procesing for hdmi, HDMI card name is
+		 * "sndhdmi" or sndhdmiraw. if card not HDMI,
+		 * strstr func just return NULL, jump to right section.
+		 * Not HDMI card, sunxi_hdmi maybe a NULL pointer.
+		 */
+		if (sunxi_ahub_daudio->tdm_num == SUNXI_AHUB_HDMI_ID) {
+			if (sunxi_hdmi->hdmi_format > 1)
+				regmap_update_bits(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_FMT0(
+					sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (5<<I2S_FMT0_SR));
+			else
+				regmap_update_bits(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_FMT0(
+					sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (3<<I2S_FMT0_SR));
+		} else {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (3<<I2S_FMT0_SR));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+				(7<<I2S_FMT0_SR), (5<<I2S_FMT0_SR));
+		break;
+	case	SNDRV_PCM_FORMAT_S32_LE:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+				(7<<I2S_FMT0_SR), (7<<I2S_FMT0_SR));
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unrecognized format\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CHCFG(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CHCFG_TX_CHANNUM),
+			((params_channels(params)-1)<<I2S_CHCFG_TX_CHANNUM));
+
+		if (sunxi_ahub_daudio->tdm_num == SUNXI_AHUB_HDMI_ID) {
+			regmap_write(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_CH0MAP0(
+				sunxi_ahub_daudio->tdm_num),
+				0x10);
+			if (sunxi_hdmi->hdmi_format > 1) {
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH1MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x32);
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH2MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x54);
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH3MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x76);
+			} else {
+				if (params_channels(params) > 2) {
+					regmap_write(sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH1MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x23);
+				/* only 5.1 & 7.1 */
+				if (params_channels(params) > 4) {
+					if (params_channels(params) == 6)
+						/* 5.1 hit this */
+						regmap_write(
+						sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH2MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x54);
+					else
+						/* 7.1 hit this */
+						regmap_write(
+						sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH2MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x76);
+				}
+				if (params_channels(params)  > 6)
+					regmap_write(sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH3MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x54);
+				}
+			}
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT1(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT1(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT2(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT2(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT3(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT3(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+		} else {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+			((params_channels(params)-1)<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+			(((1<<params_channels(params))-1)<<I2S_OUT_SLOT_EN));
+		}
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CHCFG(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CHCFG_RX_CHANNUM),
+			((params_channels(params)-1)<<I2S_CHCFG_RX_CHANNUM));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_SLOT(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_IN_SLOT_NUM),
+			((params_channels(params)-1)<<I2S_IN_SLOT_NUM));
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+
+	if (clk_set_rate(sunxi_ahub_daudio->pllclk, freq)) {
+		dev_err(sunxi_ahub_daudio->dev, "set pllclk rate failed\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_clkdiv(struct snd_soc_dai *dai,
+				int clk_id, int clk_div)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	unsigned int bclk_div, div_ratio;
+
+	if (sunxi_ahub_daudio->tdm_config)
+		/* I2S/TDM two channel mode */
+		div_ratio = clk_div / (sunxi_ahub_daudio->pcm_lrck_period * 2);
+	else
+		/* PCM mode */
+		div_ratio = clk_div / sunxi_ahub_daudio->pcm_lrck_period;
+
+	switch (div_ratio) {
+	case	1:
+		bclk_div = 1;
+		break;
+	case	2:
+		bclk_div = 2;
+		break;
+	case	4:
+		bclk_div = 3;
+		break;
+	case	6:
+		bclk_div = 4;
+		break;
+	case	8:
+		bclk_div = 5;
+		break;
+	case	12:
+		bclk_div = 6;
+		break;
+	case	16:
+		bclk_div = 7;
+		break;
+	case	24:
+		bclk_div = 8;
+		break;
+	case	32:
+		bclk_div = 9;
+		break;
+	case	48:
+		bclk_div = 10;
+		break;
+	case	64:
+		bclk_div = 11;
+		break;
+	case	96:
+		bclk_div = 12;
+		break;
+	case	128:
+		bclk_div = 13;
+		break;
+	case	176:
+		bclk_div = 14;
+		break;
+	case	192:
+		bclk_div = 15;
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unsupport clk_div\n");
+		return -EINVAL;
+	}
+
+	/* setting bclk to driver external codec bit clk */
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CLKD(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CLKD_BCLKDIV), (bclk_div<<I2S_CLKD_BCLKDIV));
+	return 0;
+}
+
+static int sunxi_ahub_daudio_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			/* HMID module, we just keep this clk */
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sunxi_ahub_daudio_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+}
+
+static struct snd_soc_dai_ops sunxi_ahub_cpu_dai_ops = {
+	.hw_params = sunxi_ahub_daudio_hw_params,
+	.set_sysclk = sunxi_ahub_daudio_set_sysclk,
+	.set_clkdiv = sunxi_ahub_daudio_set_clkdiv,
+	.set_fmt = sunxi_ahub_daudio_set_fmt,
+	.startup = sunxi_ahub_daudio_startup,
+	.trigger = sunxi_ahub_daudio_trigger,
+	.shutdown = sunxi_ahub_daudio_shutdown,
+};
+
+static int sunxi_ahub_daudio_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+
+	mutex_init(&sunxi_ahub_daudio->mutex);
+	sunxi_ahub_daudio_init(sunxi_ahub_daudio, (sunxi_ahub_daudio->tdm_num));
+	return 0;
+}
+
+static int sunxi_ahub_daudio_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_ahub_daudio_suspend(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	pr_debug("Enter %s\n", __func__);
+
+	clk_disable_unprepare(sunxi_ahub_daudio->moduleclk);
+	clk_disable_unprepare(sunxi_ahub_daudio->pllclk);
+
+
+	if (sunxi_ahub_daudio->pinconfig) {
+		ret = pinctrl_select_state(sunxi_ahub_daudio->pinctrl,
+				sunxi_ahub_daudio->pinstate_sleep);
+		if (ret) {
+			dev_warn(sunxi_ahub_daudio->dev,
+					"select i2s0-default state failed\n");
+			return -EBUSY;
+		}
+	}
+	/* Global disable I2S/TDM module */
+	sunxi_ahub_daudio_global_enable(sunxi_ahub_daudio, 0,
+				(sunxi_ahub_daudio->tdm_num));
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_resume(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				snd_soc_dai_get_drvdata(dai);
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (clk_prepare_enable(sunxi_ahub_daudio->pllclk)) {
+		dev_err(sunxi_ahub_daudio->dev, "pllclk resume failed\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_ahub_daudio->moduleclk)) {
+		dev_err(sunxi_ahub_daudio->dev, "moduleclk resume failed\n");
+		return -EBUSY;
+	}
+
+	sunxi_ahub_daudio_init(sunxi_ahub_daudio, sunxi_ahub_daudio->tdm_num);
+
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_ahub_daudio_mod = {
+	.probe = sunxi_ahub_daudio_probe,
+	.remove = sunxi_ahub_daudio_remove,
+	.suspend = sunxi_ahub_daudio_suspend,
+	.resume = sunxi_ahub_daudio_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	 },
+	.ops = &sunxi_ahub_cpu_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_ahub_daudio_component = {
+	.name		= DRV_NAME,
+};
+
+static int sunxi_ahub_daudio_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+	sunxi_ahub_daudio = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_ahub_daudio_priv), GFP_KERNEL);
+	if (!sunxi_ahub_daudio) {
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_ahub_daudio);
+	sunxi_ahub_daudio->dev = &pdev->dev;
+
+	sunxi_ahub_daudio->cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_driver), GFP_KERNEL);
+	if (!sunxi_ahub_daudio->cpudai) {
+		ret = -ENOMEM;
+		goto err_devm_kfree;
+	} else {
+		memcpy(sunxi_ahub_daudio->cpudai, &sunxi_ahub_daudio_mod,
+			sizeof(struct snd_soc_dai_driver));
+	}
+
+	sunxi_ahub_daudio->pllclk = of_clk_get(np, 0);
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pllclk)) {
+		dev_err(&pdev->dev, "pllclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->pllclk);
+		goto err_cpudai_kfree;
+	}
+
+	sunxi_ahub_daudio->moduleclk = of_clk_get(np, 1);
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->moduleclk);
+		goto err_pllclk_put;
+	}
+
+	if (clk_set_parent(sunxi_ahub_daudio->moduleclk,
+				sunxi_ahub_daudio->pllclk)) {
+		dev_err(&pdev->dev, "set parent of moduleclk to pllclk fail\n");
+		ret = -EBUSY;
+		goto err_moduleclk_put;
+	}
+	clk_prepare_enable(sunxi_ahub_daudio->pllclk);
+	clk_prepare_enable(sunxi_ahub_daudio->moduleclk);
+
+	ret = of_property_read_u32(np, "tdm_num", &temp_val);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "tdm_num configuration invalid\n");
+		goto err_moduleclk_put;
+	} else {
+		sunxi_ahub_daudio->tdm_num = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pinconfig", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pinconfig configuration invalid\n");
+		sunxi_ahub_daudio->pinconfig = 0;
+	} else {
+		sunxi_ahub_daudio->pinconfig = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "frametype", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "frametype configuration invalid\n");
+		sunxi_ahub_daudio->frame_type = 0;
+	} else {
+		sunxi_ahub_daudio->frame_type = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "daudio_master", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "daudio_master configuration invalid\n");
+		sunxi_ahub_daudio->daudio_master = 4;
+	} else {
+		sunxi_ahub_daudio->daudio_master = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pcm_lrck_period", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pcm_lrck_period configuration invalid\n");
+		sunxi_ahub_daudio->pcm_lrck_period = 0;
+	} else {
+		sunxi_ahub_daudio->pcm_lrck_period = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "slot_width_select", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "slot_width_select configuration inval\n");
+		sunxi_ahub_daudio->slot_width_select = 0;
+	} else {
+		sunxi_ahub_daudio->slot_width_select = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "audio_format", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "audio_format configuration invalid\n");
+		sunxi_ahub_daudio->audio_format = 1;
+	} else {
+		sunxi_ahub_daudio->audio_format = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "signal_inversion", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "signal_inversion configuration inval\n");
+		sunxi_ahub_daudio->signal_inversion = 1;
+	} else {
+		sunxi_ahub_daudio->signal_inversion = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tdm_config", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "tdm_config configuration invalid\n");
+		sunxi_ahub_daudio->tdm_config = 1;
+	} else {
+		sunxi_ahub_daudio->tdm_config = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "mclk_div", &temp_val);
+	if (ret < 0)
+		sunxi_ahub_daudio->mclk_div = 0;
+	else
+		sunxi_ahub_daudio->mclk_div = temp_val;
+
+	sunxi_ahub_daudio->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub_daudio->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_moduleclk_put;
+	}
+
+	/* diff handle for dais  even we use tdm_num as dai id  ----->roy */
+	sunxi_ahub_daudio->cpudai->id = sunxi_ahub_daudio->tdm_num;
+	sprintf(sunxi_ahub_daudio->cpudai_name, "sunxi-ahub-cpu-aif%d",
+					sunxi_ahub_daudio->tdm_num);
+	sunxi_ahub_daudio->cpudai->name = sunxi_ahub_daudio->cpudai_name;
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&sunxi_ahub_daudio_component,
+			sunxi_ahub_daudio->cpudai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_moduleclk_put;
+	}
+	return 0;
+
+err_moduleclk_put:
+	clk_put(sunxi_ahub_daudio->moduleclk);
+err_pllclk_put:
+	clk_put(sunxi_ahub_daudio->pllclk);
+err_cpudai_kfree:
+	kfree(sunxi_ahub_daudio->cpudai);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_ahub_daudio);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_ahub_daudio_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	clk_put(sunxi_ahub_daudio->moduleclk);
+	clk_put(sunxi_ahub_daudio->pllclk);
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_daudio_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-daudio", },
+	{},
+};
+
+static struct platform_driver sunxi_ahub_daudio_driver = {
+	.probe = sunxi_ahub_daudio_dev_probe,
+	.remove = __exit_p(sunxi_ahub_daudio_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_daudio_of_match,
+	},
+};
+
+module_platform_driver(sunxi_ahub_daudio_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-ahub");
diff --git a/sound/soc/sunxi/sunxi_dma.c b/sound/soc/sunxi/sunxi_dma.c
new file mode 100644
index 000000000..8e6f9ca61
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_dma.c
@@ -0,0 +1,546 @@
+/*
+ * sound\soc\sunxi\sunxi_dma.c
+ * (C) Copyright 2014-2016
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@Reuuimllatech.com>
+ * Liu shaohua <liushaohua@allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma/sunxi-dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <asm/dma.h>
+#include "sunxi_dma.h"
+
+static int raw_flag = 1;
+static dma_addr_t hdmiraw_dma_addr = 0;
+static dma_addr_t hdmipcm_dma_addr = 0;
+static unsigned char *hdmiraw_dma_area;	/* DMA area */
+static unsigned int channel_status[192];
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+typedef struct headbpcuv{
+	unsigned other:3;
+    unsigned V:1;
+    unsigned U:1;
+    unsigned C:1;
+    unsigned P:1;
+    unsigned B:1;
+} headbpcuv;
+
+union head61937
+{
+ headbpcuv head0;
+ unsigned char head1;
+}head;
+
+typedef union word
+{
+	struct
+	{
+		unsigned int bit0:1;
+		unsigned int bit1:1;
+		unsigned int bit2:1;
+		unsigned int bit3:1;
+		unsigned int bit4:1;
+		unsigned int bit5:1;
+		unsigned int bit6:1;
+		unsigned int bit7:1;
+		unsigned int bit8:1;
+		unsigned int bit9:1;
+		unsigned int bit10:1;
+		unsigned int bit11:1;
+		unsigned int bit12:1;
+		unsigned int bit13:1;
+		unsigned int bit14:1;
+		unsigned int bit15:1;
+		unsigned int rsvd:16;
+	}bits;
+	unsigned int wval;
+}word_format;
+static const struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				      SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+				      SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 8,
+	.buffer_bytes_max	= 1024*1024,    /* value must be (2^n)Kbyte size */
+	.period_bytes_min	= 256,
+	.period_bytes_max	= 1024*256,
+	.periods_min		= 1,
+	.periods_max		= 8,
+	.fifo_size		= 128,
+};
+
+int sunxi_ahub_get_rawflag(void)
+{
+	return raw_flag;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_get_rawflag);
+
+int hdmi_transfer_format_61937_to_60958(int *out, short *temp,
+					int samples, int rate)
+{
+	int ret =0;
+	int i;
+	static int numtotal = 0;
+	union word w1;
+
+	samples>>=1;
+	head.head0.other = 0;
+	head.head0.B = 1;
+	head.head0.P = 0;
+	head.head0.C = 0;
+	head.head0.U = 0;
+	head.head0.V = 1;
+
+	for (i=0 ; i<192; i++)
+		channel_status[i] = 0;
+
+	channel_status[1] = 1;
+	/* sample rates */
+	if (rate == 32000) {
+		channel_status[24] = 1;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == 44100) {
+		channel_status[24] = 0;
+		channel_status[25] = 0;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == 48000) {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == (32000*4)) {
+		channel_status[24] = 1;
+		channel_status[25] = 0;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == (44100*4)) {
+		channel_status[24] = 0;
+		channel_status[25] = 0;
+		channel_status[26] = 1;
+		channel_status[27] = 1;
+	} else if (rate == (48000*4)) {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 1;
+		channel_status[27] = 1;
+		if (raw_flag == 12 || raw_flag == 11) {
+			channel_status[24] = 1;
+			channel_status[25] = 0;
+			channel_status[26] = 0;
+			channel_status[27] = 1;
+		}
+	} else {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	}
+
+	for (i = 0 ;i<samples;i++,numtotal++) {
+		if ((numtotal%384 == 0) || (numtotal%384 == 1))
+			head.head0.B = 1;
+		else
+			head.head0.B = 0;
+
+		head.head0.C = channel_status[(numtotal%384)/2];
+
+		if (numtotal%384 == 0)
+			numtotal = 0;
+
+		w1.wval = (*temp)&(0xffff);
+
+		head.head0.P = w1.bits.bit15 ^ w1.bits.bit14 ^ w1.bits.bit13
+			^ w1.bits.bit12 ^ w1.bits.bit11 ^ w1.bits.bit10
+			^ w1.bits.bit9 ^ w1.bits.bit8 ^ w1.bits.bit7
+			^ w1.bits.bit6 ^ w1.bits.bit5 ^ w1.bits.bit4
+			^ w1.bits.bit3 ^ w1.bits.bit2 ^ w1.bits.bit1
+			^ w1.bits.bit0;
+
+		ret = (int)(head.head1)<<24;
+		ret |= (int)((w1.wval)&(0xffff))<<11;//8 or 12
+		*out = ret;
+		out++;
+		temp++;
+	}
+	return 0;
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct sunxi_dma_params *dmap;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->platform->dev;
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct dma_slave_config slave_config;
+	int ret;
+
+	dmap = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params, &slave_config);
+	if (ret) {
+		dev_err(dev, "hw params config failed with err %d\n", ret);
+		return ret;
+	}
+
+	slave_config.dst_maxburst = dmap->dst_maxburst;
+	slave_config.src_maxburst = dmap->src_maxburst;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.dst_addr = dmap->dma_addr;
+		slave_config.src_addr_width = slave_config.dst_addr_width;
+		slave_config.slave_id = sunxi_slave_id(dmap->dma_drq_type_num, DRQSRC_SDRAM);
+	} else {
+		slave_config.src_addr =	dmap->dma_addr;
+		slave_config.dst_addr_width = slave_config.src_addr_width;
+		slave_config.slave_id = sunxi_slave_id(DRQDST_SDRAM, dmap->dma_drq_type_num);
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret < 0) {
+		dev_err(dev, "dma slave config failed with err %d\n", ret);
+		return ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+
+static int sunxi_pcm_hdmi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct device *dev = card->dev;
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct dma_slave_config slave_config;
+	struct sunxi_dma_params *dmap;
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	raw_flag = sunxi_hdmi->hdmi_format;
+	pr_info("raw_flag value is %u\n", raw_flag);
+	dmap = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params, &slave_config);
+	if (ret) {
+		dev_err(dev, "hw params config failed with err %d\n", ret);
+		return ret;
+	}
+
+	slave_config.dst_maxburst = dmap->dst_maxburst;
+	slave_config.src_maxburst = dmap->src_maxburst;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.dst_addr =	dmap->dma_addr;
+		slave_config.src_addr_width = slave_config.dst_addr_width;
+		slave_config.slave_id = sunxi_slave_id(dmap->dma_drq_type_num, DRQSRC_SDRAM);
+	} else {
+		slave_config.src_addr =	dmap->dma_addr;
+		slave_config.dst_addr_width = slave_config.src_addr_width;
+		slave_config.slave_id = sunxi_slave_id(DRQDST_SDRAM, dmap->dma_drq_type_num);
+	}
+
+	/*raw_flag>1. rawdata*/
+	if (raw_flag > 1) {
+		slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+#ifndef CONFIG_SND_SUNXI_SOC_AHUB
+		strcpy(substream->pcm->card->id, "sndhdmiraw");
+#endif
+		if (!dev->dma_mask)
+			dev->dma_mask = &sunxi_pcm_mask;
+		if (!dev->coherent_dma_mask)
+			dev->coherent_dma_mask = 0xffffffff;
+
+		hdmiraw_dma_area = dma_alloc_coherent(dev, (2*params_buffer_bytes(params)), &hdmiraw_dma_addr, GFP_KERNEL);
+		if (hdmiraw_dma_area == NULL) {
+			pr_err("hdmi:raw:get mem failed...\n");
+			return -ENOMEM;
+		}
+		hdmipcm_dma_addr = substream->dma_buffer.addr;
+		substream->dma_buffer.addr = (dma_addr_t)hdmiraw_dma_addr;
+	} else {
+#ifndef CONFIG_SND_SUNXI_SOC_AHUB
+		strcpy(substream->pcm->card->id, "sndhdmi");
+#endif
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret < 0) {
+		dev_err(dev, "dma slave config failed with err %d\n", ret);
+		return ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+static int sunxi_pcm_hdmi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->platform->dev;
+	if (snd_pcm_lib_buffer_bytes(substream)&& (raw_flag > 1)) {
+		dma_free_coherent(dev, (2*snd_pcm_lib_buffer_bytes(substream)),
+					      hdmiraw_dma_area, hdmiraw_dma_addr);
+		substream->dma_buffer.addr = hdmipcm_dma_addr;
+		hdmiraw_dma_area = NULL;
+	}
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream, SNDRV_PCM_TRIGGER_START);
+		return 0;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream, SNDRV_PCM_TRIGGER_STOP);
+		return 0;
+		}
+	} else {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream, SNDRV_PCM_TRIGGER_START);
+		return 0;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream, SNDRV_PCM_TRIGGER_STOP);
+		return 0;
+		}
+	}
+	return 0;
+}
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->platform->dev;
+	/* Set HW params now that initialization is complete */
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+	ret = snd_dmaengine_pcm_open_request_chan(substream, NULL,
+				NULL);
+	if (ret) {
+		dev_err(dev, "dmaengine pcm open failed with err %d\n", ret);
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = NULL;
+	if (substream->runtime!=NULL) {
+		runtime = substream->runtime;
+
+		return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+					     runtime->dma_area,
+					     runtime->dma_addr,
+					     runtime->dma_bytes);
+	} else {
+		return -1;
+	}
+
+}
+
+static int sunxi_pcm_copy(struct snd_pcm_substream *substream, int a,
+	 snd_pcm_uframes_t hwoff, void __user *buf, snd_pcm_uframes_t frames)
+{
+	int ret = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames))) {
+			return -EFAULT;
+		}
+		if (raw_flag > 1) {
+			char* hdmihw_area = hdmiraw_dma_area + 2*frames_to_bytes(runtime, hwoff);
+			hdmi_transfer_format_61937_to_60958((int *)hdmihw_area,
+				(short *)hwbuf,
+				frames_to_bytes(runtime, frames),
+				runtime->rate);
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames))) {
+			return -EFAULT;
+		}
+	}
+
+	return ret;
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open			= sunxi_pcm_open,
+	.close			= snd_dmaengine_pcm_close_release_chan,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params		= sunxi_pcm_hw_params,
+	.hw_free		= sunxi_pcm_hw_free,
+	.trigger		= sunxi_pcm_trigger,
+	.pointer		= snd_dmaengine_pcm_pointer,
+	.mmap			= sunxi_pcm_mmap,
+};
+
+static struct snd_pcm_ops sunxi_pcm_ops_no_residue = {
+	.open			= sunxi_pcm_open,
+	.close			= snd_dmaengine_pcm_close_release_chan,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params		= sunxi_pcm_hdmi_hw_params,
+	.hw_free		= sunxi_pcm_hdmi_hw_free,
+	.trigger		= sunxi_pcm_trigger,
+	.pointer		= snd_dmaengine_pcm_pointer_no_residue,
+	.mmap			= sunxi_pcm_mmap,
+	.copy_user			= sunxi_pcm_copy,
+};
+static int sunxi_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = 0;
+	size = sunxi_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+
+	return 0;
+}
+
+static void sunxi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				      			buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ 	out:
+		return ret;
+}
+
+static struct snd_soc_platform_driver sunxi_soc_platform = {
+	.ops		= &sunxi_pcm_ops,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+
+static const struct snd_soc_platform_driver sunxi_soc_platform_no_residue = {
+	.ops		= &sunxi_pcm_ops_no_residue,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+int asoc_dma_platform_register(struct device *dev,unsigned int flags)
+{
+	if (flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)
+		return snd_soc_register_platform(dev, &sunxi_soc_platform_no_residue);
+	else
+		return snd_soc_register_platform(dev, &sunxi_soc_platform);
+}
+EXPORT_SYMBOL_GPL(asoc_dma_platform_register);
+
+void asoc_dma_platform_unregister(struct device *dev)
+{
+	snd_soc_unregister_platform(dev);
+}
+EXPORT_SYMBOL_GPL(asoc_dma_platform_unregister);
+
+MODULE_AUTHOR("huangxin, liushaohua");
+MODULE_DESCRIPTION("sunxi ASoC DMA Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi_dma.h b/sound/soc/sunxi/sunxi_dma.h
new file mode 100644
index 000000000..c166e0800
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_dma.h
@@ -0,0 +1,32 @@
+/* sound\soc\sunxi\sunxi_dma.h
+ * (C) Copyright 2014-2017
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * chenpailin <chenpailin@Reuuimllatech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef SUNXI_DMA_H_
+#define SUNXI_DMA_H_
+
+struct sunxi_dma_params {
+	char *name;
+	dma_addr_t dma_addr;
+	u8 src_maxburst;
+	u8 dst_maxburst;
+	u8 dma_drq_type_num;
+};
+
+struct sunxi_hdmi_priv {
+	unsigned int hdmi_format;
+};
+
+extern int asoc_dma_platform_register(struct device *dev,unsigned int flags);
+extern void asoc_dma_platform_unregister(struct device *dev);
+extern int sunxi_ahub_get_rawflag(void);
+#endif
diff --git a/sound/soc/sunxi/sunxi_dmic.c b/sound/soc/sunxi/sunxi_dmic.c
new file mode 100644
index 000000000..30e2ea460
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_dmic.c
@@ -0,0 +1,548 @@
+/*
+ * sound\soc\sunxi\sunxi-dmic.c
+ * (C) Copyright 2014-2016
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnerrecg.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/dma/sunxi-dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include "sunxi_dma.h"
+#include "sunxi_dmic.h"
+
+#define	DRV_NAME	"sunxi-dmic"
+
+#ifdef CONFIG_SUN50IW6
+#undef	DMIC_AUDIO_DEMAND
+#else
+#define DMIC_AUDIO_DEMAND
+#endif
+
+struct dmic_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+struct dmic_chmap {
+	unsigned int chan;
+	unsigned int chan_bit;
+};
+
+struct sunxi_dmic_info {
+	struct regmap   *regmap;
+	struct regulator *power_supply;
+	struct clk *pllclk;
+	struct clk *moduleclk;
+	struct device *dev;
+	struct snd_soc_dai_driver dai;
+	struct sunxi_dma_params capture_dma_param;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state  *pinstate;
+	struct pinctrl_state  *pinstate_sleep;
+	u32 chanmap;
+};
+
+static const struct dmic_rate dmic_rate_s[] = {
+	{44100, 0x0},
+	{48000, 0x0},
+	{22050, 0x2},
+	/* KNOT support */
+	{24000, 0x2},
+	{11025, 0x4},
+	{12000, 0x4},
+	{32000, 0x1},
+	{16000, 0x3},
+	{8000, 0x5},
+};
+
+/*
+ * Configure DMA , Chan enable & Global enable
+ */
+static void sunxi_dmic_enable(struct sunxi_dmic_info *sunxi_dmic, int enable)
+{
+	if (enable) {
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_INTC,
+					(1<<FIFO_DRQ_EN), (1<<FIFO_DRQ_EN));
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_EN,
+		(0xFF<<DATA_CH_EN), ((sunxi_dmic->chanmap)<<DATA_CH_EN));
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_EN,
+					(1<<GLOBE_EN), (1<<GLOBE_EN));
+	} else {
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_EN,
+					(1<<GLOBE_EN), (0<<GLOBE_EN));
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_EN,
+					(0xFF<<DATA_CH_EN), (0<<DATA_CH_EN));
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_INTC,
+					(1<<FIFO_DRQ_EN), (0<<FIFO_DRQ_EN));
+	}
+}
+
+static void sunxi_dmic_init(struct sunxi_dmic_info *sunxi_dmic)
+{
+	regmap_write(sunxi_dmic->regmap,
+		SUNXI_DMIC_CH_MAP, DMIC_CHANMAP_DEFAULT);
+
+	regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_CTR,
+			(7<<DMICDFEN), (5<<DMICDFEN));
+	/* set the vol */
+	regmap_write(sunxi_dmic->regmap,
+			SUNXI_DMIC_DATA0_1_VOL, DMIC_DEFAULT_VOL);
+	regmap_write(sunxi_dmic->regmap,
+			SUNXI_DMIC_DATA2_3_VOL, DMIC_DEFAULT_VOL);
+}
+
+static int sunxi_dmic_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	int i;
+
+	/* sample resolution & sample fifo format */
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_FIFO_CTR,
+				(3<<SAMPLE_RESOLUTION), (2<<SAMPLE_RESOLUTION));
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_FIFO_CTR,
+				(3<<SAMPLE_RESOLUTION), (1<<SAMPLE_RESOLUTION));
+		break;
+	default:
+		dev_err(sunxi_dmic->dev, "Invalid format set\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dmic_rate_s); i++) {
+		if (dmic_rate_s[i].samplerate == params_rate(params)) {
+			regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_SR,
+			(7<<DMIC_SR), (dmic_rate_s[i].rate_bit<<DMIC_SR));
+			break;
+		}
+	}
+
+	/* oversamplerate adjust */
+	if (params_rate(params) >= 24000) {
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_CTR,
+			(1<<DMIC_OVERSAMPLE_RATE), (1<<DMIC_OVERSAMPLE_RATE));
+	} else {
+		regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_CTR,
+			(1<<DMIC_OVERSAMPLE_RATE), (0<<DMIC_OVERSAMPLE_RATE));
+	}
+
+	sunxi_dmic->chanmap = (1<<params_channels(params)) - 1;
+
+	regmap_write(sunxi_dmic->regmap,
+		SUNXI_DMIC_HPF_CTRL, sunxi_dmic->chanmap);
+
+	/* DMIC num is M+1 */
+	regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_CH_NUM,
+		(7<<DMIC_CH_NUM), ((params_channels(params)-1)<<DMIC_CH_NUM));
+
+	return 0;
+}
+
+static int sunxi_dmic_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		sunxi_dmic_enable(sunxi_dmic, 1);
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sunxi_dmic_enable(sunxi_dmic, 0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+/*
+ * Reset & Flush FIFO
+ */
+static int sunxi_dmic_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	regmap_write(sunxi_dmic->regmap, SUNXI_DMIC_INTS,
+		(1<<FIFO_OVERRUN_IRQ_PENDING) | (1<<FIFO_DATA_IRQ_PENDING));
+
+	regmap_write(sunxi_dmic->regmap, SUNXI_DMIC_CNT, 0x0);
+
+	regmap_write(sunxi_dmic->regmap, SUNXI_DMIC_FIFO_STA, 0x0);
+
+	regmap_update_bits(sunxi_dmic->regmap, SUNXI_DMIC_FIFO_CTR,
+			(1<<DMIC_FIFO_FLUSH), (1<<DMIC_FIFO_FLUSH));
+
+	return 0;
+}
+
+static int sunxi_dmic_startup(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_set_dma_data(dai, substream,
+				&sunxi_dmic->capture_dma_param);
+
+	return 0;
+}
+
+static int sunxi_dmic_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+						unsigned int freq, int dir)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	if (clk_set_rate(sunxi_dmic->pllclk, freq)) {
+		dev_err(sunxi_dmic->dev, "Freq : %u not support\n", freq);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Dmic module init status */
+static int sunxi_dmic_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	sunxi_dmic_init(sunxi_dmic);
+	return 0;
+}
+
+static int sunxi_dmic_suspend(struct snd_soc_dai *cpu_dai)
+{
+	u32 ret = 0;
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	pr_debug("[DMIC]Enter %s\n", __func__);
+
+	if (NULL != sunxi_dmic->pinstate_sleep) {
+		ret = pinctrl_select_state(sunxi_dmic->pinctrl, sunxi_dmic->pinstate_sleep);
+		if (ret) {
+			pr_warn("[dmic]select pin sleep state failed\n");
+			return ret;
+		}
+	}
+	if (sunxi_dmic->pinctrl !=NULL)
+		devm_pinctrl_put(sunxi_dmic->pinctrl);
+	sunxi_dmic->pinctrl = NULL;
+	sunxi_dmic->pinstate = NULL;
+	sunxi_dmic->pinstate_sleep = NULL;
+	if (sunxi_dmic->moduleclk != NULL)
+		clk_disable(sunxi_dmic->moduleclk);
+	if (sunxi_dmic->pllclk != NULL)
+		clk_disable(sunxi_dmic->pllclk);
+
+	pr_debug("[DMIC]End %s\n", __func__);
+	return 0;
+}
+
+static int sunxi_dmic_resume(struct snd_soc_dai *cpu_dai)
+{
+	s32 ret = 0;
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	pr_debug("[DMIC]Enter %s\n", __func__);
+
+	if (sunxi_dmic->pllclk != NULL) {
+		if (clk_prepare_enable(sunxi_dmic->pllclk)) {
+			pr_err("open sunxi_dmic->pllclk failed! line = %d\n", __LINE__);
+		}
+	}
+
+	if (sunxi_dmic->moduleclk != NULL) {
+		if (clk_prepare_enable(sunxi_dmic->moduleclk)) {
+			pr_err("open sunxi_dmic->moduleclk failed! line = %d\n", __LINE__);
+		}
+	}
+
+	if (!sunxi_dmic->pinctrl) {
+		sunxi_dmic->pinctrl = devm_pinctrl_get(cpu_dai->dev);
+		if (IS_ERR_OR_NULL(sunxi_dmic->pinctrl)) {
+			pr_warn("[dmic]request pinctrl handle for audio failed\n");
+			return -EINVAL;
+		}
+	}
+	if (!sunxi_dmic->pinstate){
+		sunxi_dmic->pinstate = pinctrl_lookup_state(sunxi_dmic->pinctrl, PINCTRL_STATE_DEFAULT);
+		if (IS_ERR_OR_NULL(sunxi_dmic->pinstate)) {
+			pr_warn("[dmic]lookup pin default state failed\n");
+			return -EINVAL;
+		}
+	}
+
+	if (!sunxi_dmic->pinstate_sleep){
+		sunxi_dmic->pinstate_sleep = pinctrl_lookup_state(sunxi_dmic->pinctrl, PINCTRL_STATE_SLEEP);
+		if (IS_ERR_OR_NULL(sunxi_dmic->pinstate_sleep)) {
+			pr_warn("[dmic]lookup pin sleep state failed\n");
+			return -EINVAL;
+		}
+	}
+
+	ret = pinctrl_select_state(sunxi_dmic->pinctrl, sunxi_dmic->pinstate);
+	if (ret) {
+		pr_warn("[dmic]select pin default state failed\n");
+		return ret;
+	}
+
+	sunxi_dmic_init(sunxi_dmic);
+	pr_debug("[DMIC]End %s\n", __func__);
+	return 0;
+}
+
+#define	SUNXI_DMIC_RATES (SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_dmic_dai_ops = {
+	.startup = sunxi_dmic_startup,
+	.trigger = sunxi_dmic_trigger,
+	.prepare = sunxi_dmic_prepare,
+	.hw_params = sunxi_dmic_hw_params,
+	.set_sysclk = sunxi_dmic_set_sysclk,
+};
+
+static struct snd_soc_dai_driver sunxi_dmic_dai = {
+	.probe = sunxi_dmic_probe,
+	.suspend = sunxi_dmic_suspend,
+	.resume = sunxi_dmic_resume,
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SUNXI_DMIC_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &sunxi_dmic_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_dmic_component = {
+	.name = DRV_NAME,
+};
+
+static const struct regmap_config sunxi_dmic_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_DMIC_HPF_GAIN,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int  sunxi_dmic_dev_probe(struct platform_device *pdev)
+{
+	struct resource res, *memregion;
+	struct device_node *np = pdev->dev.of_node;
+	struct sunxi_dmic_info *sunxi_dmic;
+	void __iomem *sunxi_dmic_membase = NULL;
+	int ret;
+
+	sunxi_dmic = devm_kzalloc(&pdev->dev, sizeof(struct sunxi_dmic_info), GFP_KERNEL);
+	if (!sunxi_dmic) {
+		dev_err(&pdev->dev, "sunxi_dmic allocate failed\n");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_dmic);
+
+	sunxi_dmic->dev = &pdev->dev;
+	sunxi_dmic->dai = sunxi_dmic_dai;
+	sunxi_dmic->dai.name = dev_name(&pdev->dev);
+
+#ifdef DMIC_AUDIO_DEMAND
+	sunxi_dmic->power_supply = regulator_get(&pdev->dev, "audio-33");
+	if (IS_ERR(sunxi_dmic->power_supply)) {
+		dev_err(&pdev->dev, "Failed to get sunxi dmic power supply\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	} else {
+		ret = regulator_set_voltage(sunxi_dmic->power_supply,
+					3300000, 3300000);
+		if (ret)
+			dev_warn(&pdev->dev, "Failed to set sunxi dmic power supply to 3.3V\n");
+		ret = regulator_enable(sunxi_dmic->power_supply);
+		if (ret) {
+			dev_err(&pdev->dev, "Failed to enable sunxi dmic power supply\n");
+			ret = -EBUSY;
+			goto err_regulator_put;
+		}
+	}
+#endif
+
+	ret = of_address_to_resource(np, 0 , &res);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to get sunxi dmic resource\n");
+		ret = -EINVAL;
+		goto err_regulator_put;
+	}
+
+	memregion = devm_request_mem_region(&pdev->dev, res.start,
+					    resource_size(&res), DRV_NAME);
+	if (!memregion) {
+		dev_err(&pdev->dev, "sunxi dmic memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_regulator_put;
+	}
+
+	sunxi_dmic_membase = devm_ioremap(&pdev->dev,
+					res.start, resource_size(&res));
+	if (!sunxi_dmic_membase) {
+		dev_err(&pdev->dev, "sunxi dmic ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_regulator_put;
+	}
+
+	sunxi_dmic->regmap = devm_regmap_init_mmio(&pdev->dev,
+				sunxi_dmic_membase, &sunxi_dmic_regmap_config);
+	if (IS_ERR_OR_NULL(sunxi_dmic->regmap)) {
+		dev_err(&pdev->dev, "sunxi dmic registers regmap failed\n");
+		ret = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	sunxi_dmic->pllclk = of_clk_get(np, 0);
+	sunxi_dmic->moduleclk = of_clk_get(np, 1);
+	if (IS_ERR(sunxi_dmic->pllclk) || IS_ERR(sunxi_dmic->moduleclk)){
+		dev_err(&pdev->dev, "Can't get dmic pll clocks\n");
+		if (IS_ERR(sunxi_dmic->pllclk)) {
+			ret = PTR_ERR(sunxi_dmic->pllclk);
+			goto err_iounmap;
+		} else {
+			ret = PTR_ERR(sunxi_dmic->moduleclk);
+			goto err_pllclk_put;
+		}
+	} else {
+		if (clk_set_parent(sunxi_dmic->moduleclk, sunxi_dmic->pllclk)) {
+			pr_err("try to set parent of sunxi_dmic->moduleclk to sunxi_dmic->pllclk failed! line = %d\n",__LINE__);
+		}
+		clk_prepare_enable(sunxi_dmic->pllclk);
+		clk_prepare_enable(sunxi_dmic->moduleclk);
+	}
+
+	/* FIXME */
+	sunxi_dmic->capture_dma_param.dma_addr = res.start + SUNXI_DMIC_DATA;
+	sunxi_dmic->capture_dma_param.dma_drq_type_num = DRQSRC_DMIC;
+	sunxi_dmic->capture_dma_param.src_maxburst = 8;
+	sunxi_dmic->capture_dma_param.dst_maxburst = 8;
+
+	sunxi_dmic->pinctrl = NULL;
+	if (!sunxi_dmic->pinctrl) {
+		sunxi_dmic->pinctrl = devm_pinctrl_get(&pdev->dev);
+		if (IS_ERR_OR_NULL(sunxi_dmic->pinctrl)) {
+			dev_err(&pdev->dev, "request pinctrl handle for audio failed\n");
+			ret =  -EINVAL;
+			goto err_moduleclk_put;
+		}
+	}
+	if (!sunxi_dmic->pinstate){
+		sunxi_dmic->pinstate = pinctrl_lookup_state(sunxi_dmic->pinctrl, PINCTRL_STATE_DEFAULT);
+		if (IS_ERR_OR_NULL(sunxi_dmic->pinstate)) {
+			dev_err(&pdev->dev, "lookup pin default state failed\n");
+			ret = -EINVAL;
+			goto err_pinctrl_put;
+		}
+	}
+
+	if (!sunxi_dmic->pinstate_sleep){
+		sunxi_dmic->pinstate_sleep = pinctrl_lookup_state(sunxi_dmic->pinctrl, PINCTRL_STATE_SLEEP);
+		if (IS_ERR_OR_NULL(sunxi_dmic->pinstate_sleep)) {
+			dev_err(&pdev->dev, "lookup pin sleep state failed\n");
+			ret = -EINVAL;
+			goto err_pinctrl_put;
+		}
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_dmic_component,
+				   &sunxi_dmic->dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_pinctrl_put;
+	}
+
+	ret = asoc_dma_platform_register(&pdev->dev,0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_unregister_component;
+	}
+
+	return 0;
+
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_pinctrl_put:
+	devm_pinctrl_put(sunxi_dmic->pinctrl);
+err_moduleclk_put:
+	clk_put(sunxi_dmic->moduleclk);
+err_pllclk_put:
+	clk_put(sunxi_dmic->pllclk);
+err_iounmap:
+	iounmap(sunxi_dmic_membase);
+err_regulator_put:
+#ifdef DMIC_AUDIO_DEMAND
+	regulator_put(sunxi_dmic->power_supply);
+err_devm_kfree:
+#endif
+	devm_kfree(&pdev->dev, sunxi_dmic);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_dmic_dev_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static const struct of_device_id sunxi_dmic_of_match[] = {
+	{ .compatible = "allwinner,sunxi-dmic", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sunxi_dmic_of_match);
+
+static struct platform_driver sunxi_dmic_driver = {
+	.probe = sunxi_dmic_dev_probe,
+	.remove = __exit_p(sunxi_dmic_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_dmic_of_match,
+	},
+};
+
+module_platform_driver(sunxi_dmic_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI DMIC Machine ASoC driver");
+MODULE_ALIAS("platform:sunxi-dmic");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi_dmic.h b/sound/soc/sunxi/sunxi_dmic.h
new file mode 100644
index 000000000..cb3df77c4
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_dmic.h
@@ -0,0 +1,112 @@
+/*
+ * sound\soc\sunxi\sunxi_dmic.h
+ * (C) Copyright 2010-2016
+ * Reuuimlla Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_DMIC_H
+#define __SUNXI_DMIC_H
+
+/*------------------DMIC register definition--------------------*/
+#define SUNXI_DMIC_EN 			0x00
+#define SUNXI_DMIC_SR			0x04
+#define SUNXI_DMIC_CTR			0x08
+#define SUNXI_DMIC_DATA			0x10
+#define SUNXI_DMIC_INTC			0x14
+#define SUNXI_DMIC_INTS			0x18
+#define SUNXI_DMIC_FIFO_CTR		0x1c
+#define SUNXI_DMIC_FIFO_STA		0x20
+#define SUNXI_DMIC_CH_NUM		0x24
+#define SUNXI_DMIC_CH_MAP		0x28
+#define SUNXI_DMIC_CNT			0x2c
+#define SUNXI_DMIC_DATA0_1_VOL		0x30
+#define SUNXI_DMIC_DATA2_3_VOL		0x34
+#define	SUNXI_DMIC_HPF_CTRL		0x38
+#define	SUNXI_DMIC_HPF_COEF		0x3C
+#define	SUNXI_DMIC_HPF_GAIN		0x40
+
+/*0x00:SUNXI_DMIC_EN*/
+#define GLOBE_EN				8
+#define DATA3_CHR_EN			7
+#define DATA3_CHL_EN			6
+#define DATA2_CHR_EN			5
+#define DATA2_CHL_EN			4
+#define DATA1_CHR_EN			3
+#define DATA1_CHL_EN			2
+#define DATA0_CHR_EN			1
+#define DATA0_CHL_EN			0
+#define DATA_CH_EN				0
+
+/*SUNXI_DMIC_SR:0x04*/
+#define DMIC_SR					0
+
+/*SUNXI_DMIC_CTR:0x08*/
+#define DMICFDT					9
+#define DMICDFEN				8
+#define DATA3_LR_SWEEP_EN		7
+#define DATA2_LR_SWEEP_EN		6
+#define DATA1_LR_SWEEP_EN		5
+#define DATA0_LR_SWEEP_EN		4
+#define DMIC_OVERSAMPLE_RATE	0
+
+/*SUNXI_DMIC_DATA:0x10*/
+#define DMIC_DATA				0
+
+/*SUNXI_DMIC_INTC:0x14*/
+#define FIFO_DRQ_EN				2
+#define FIFO_OVERRUN_IRQ_EN		1
+#define DATA_IRQ_EN				0
+
+/*SUNXI_DMIC_INTS:0x18*/
+#define FIFO_OVERRUN_IRQ_PENDING	1
+#define FIFO_DATA_IRQ_PENDING		0
+
+/*SUNXI_DMIC_FIFO_CTR:0x1c*/
+#define DMIC_FIFO_FLUSH			31
+#define FIFO_MODE				9
+#define SAMPLE_RESOLUTION		8
+#define FIFO_TRG_LEVEL			0
+
+/*SUNXI_DMIC_FIFO_STA:0x20*/
+#define DMIC_DATA_CNT			0
+
+/*SUNXI_DMIC_CH_NUM:0x24*/
+#define DMIC_CH_NUM				0
+
+/*SUNXI_DMIC_CH_MAP:0x28*/
+#define DMIC_CH7_MAP			28
+#define DMIC_CH6_MAP			24
+#define DMIC_CH5_MAP			20
+#define DMIC_CH4_MAP			16
+#define DMIC_CH3_MAP			12
+#define DMIC_CH2_MAP			8
+#define DMIC_CH1_MAP			4
+#define DMIC_CH0_MAP			0
+#define DMIC_CHANMAP_DEFAULT	(0x76543210)
+/*SUNXI_DMIC_CNT:0x2c*/
+#define DMIC_CUNT				0
+
+/*SUNXI_DMIC_DATA0_1_VOL:0x30*/
+#define DATA1L_VOL				24
+#define DATA1R_VOL				16
+#define DATA0L_VOL				8
+#define DATA0R_VOL				0
+
+/*SUNXI_DMIC_DATA2_3_VOL:0x34*/
+#define DATA3L_VOL				24
+#define DATA3R_VOL				16
+#define DATA2L_VOL				8
+#define DATA2R_VOL				0
+#define	DMIC_DEFAULT_VOL		0xB0B0B0B0
+
+#endif /* SUNXI_DMIC_H */
+
diff --git a/sound/soc/sunxi/sunxi_netlink.c b/sound/soc/sunxi/sunxi_netlink.c
new file mode 100644
index 000000000..ad44f1746
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_netlink.c
@@ -0,0 +1,267 @@
+/*
+ * Copyright (c) 2016 AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/netdevice.h>
+#include <net/netlink.h>
+#include <net/sock.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+
+#define	EVT_MAX_SIZE		256
+#define	NETLINK_PCM_SUNXI	31
+
+#undef	SUNXI_NETLINK_TEST
+
+enum {
+	SNDRV_PCM_NETLINK_CLOSE,
+	SNDRV_PCM_NETLINK_START,
+	SNDRV_PCM_NETLINK_NOUSE,
+};
+
+#ifdef	SUNXI_NETLINK_TEST
+static void sunxi_netlink_period(struct work_struct *ws);
+DECLARE_DELAYED_WORK(writer_work, sunxi_netlink_period);
+#endif
+
+struct evt_entry {
+	struct list_head list;
+	char evt_data[EVT_MAX_SIZE];
+	int size;
+};
+
+struct xrun_event {
+	int ref_cnt;
+	struct sock *sock;
+	struct list_head evtq;
+	spinlock_t evt_lock;
+	struct list_head freeq;
+	struct work_struct ws;
+};
+
+struct pcm_netlink_status {
+	int pid;
+	int status;
+	struct mutex mutex_lock;
+};
+
+static struct xrun_event pcm_event;
+static struct pcm_netlink_status pcm_netlink;
+
+static void free_event_entry(struct evt_entry *e)
+{
+	kfree(e);
+}
+
+static inline struct evt_entry *alloc_evt_entry(void)
+{
+	return kmalloc(sizeof(struct evt_entry), GFP_ATOMIC);
+}
+
+static struct evt_entry *get_evt_entry(void)
+{
+	struct evt_entry *e;
+
+	if (list_empty(&pcm_event.freeq))
+		e = alloc_evt_entry();
+	else {
+		e = list_entry(pcm_event.freeq.next, struct evt_entry, list);
+		list_del(&e->list);
+	}
+
+	return e;
+}
+
+static void put_evt_entry(struct evt_entry *e)
+{
+	list_add_tail(&e->list, &pcm_event.freeq);
+}
+
+static int netlink_send(struct sock *sock, int group,
+		u16 type, void *msg, int len)
+{
+	struct sk_buff *skb = NULL;
+	struct nlmsghdr *nlh;
+	int ret = 0;
+
+	skb = nlmsg_new(len, GFP_ATOMIC);
+	if (!skb) {
+		kfree_skb(skb);
+		return -EMSGSIZE;
+	}
+
+	nlh = nlmsg_put(skb, 0, 0, type, len, 0);
+	if (!nlh) {
+		kfree_skb(skb);
+		return -EMSGSIZE;
+	}
+	memcpy(nlmsg_data(nlh), msg, len);
+
+	NETLINK_CB(skb).portid = 0;
+	NETLINK_CB(skb).dst_group = 0;
+
+	if (pcm_netlink.status > SNDRV_PCM_NETLINK_CLOSE) {
+		ret = netlink_unicast(sock, skb, pcm_netlink.pid, GFP_ATOMIC);
+		if (ret < 0)
+			pcm_netlink.status = SNDRV_PCM_NETLINK_CLOSE;
+	}
+	return ret;
+}
+
+static void _pcm_event_send(struct work_struct *work)
+{
+	unsigned long flags;
+	struct evt_entry *e;
+
+	spin_lock_irqsave(&pcm_event.evt_lock, flags);
+
+	while (!list_empty(&pcm_event.evtq)) {
+		e = list_entry(pcm_event.evtq.next, struct evt_entry, list);
+		spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+		netlink_send(pcm_event.sock, 0, 0, e->evt_data, e->size);
+		spin_lock_irqsave(&pcm_event.evt_lock, flags);
+		list_del(&e->list);
+		put_evt_entry(e);
+	}
+
+	spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+}
+
+static void netlink_rcv(struct sk_buff *skb)
+{
+	struct nlmsghdr *nlh;
+	int pid;
+
+	nlh = (struct nlmsghdr *)skb->data;
+	pid = nlh->nlmsg_pid; /*pid of sending process */
+
+	/* user start capture? */
+	if (!strncmp(nlmsg_data(nlh), "start", 5)) {
+		pcm_netlink.pid = pid;
+		pcm_netlink.status = SNDRV_PCM_NETLINK_START;
+	}
+	if (!strncmp(nlmsg_data(nlh), "close", 5))
+		pcm_netlink.status = SNDRV_PCM_NETLINK_CLOSE;
+
+#ifdef	SUNXI_NETLINK_TEST
+	if (pcm_netlink.status)
+		schedule_delayed_work(&writer_work, 5 * HZ);
+#endif
+}
+
+static void printk_convert(struct evt_entry *e, const char *fmt, va_list args)
+{
+	e->size = vscnprintf(e->evt_data, EVT_MAX_SIZE, fmt, args);
+
+	/* mark and strip a trailing newline */
+	if (e->size && e->evt_data[e->size - 1] == '\n')
+		e->size--;
+}
+
+void sunxi_netlink_printd(const char *fmt, ...)
+{
+	va_list args;
+	struct evt_entry *e;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pcm_event.evt_lock, flags);
+	e = get_evt_entry();
+	if (!e) {
+		pr_err("pcm netlink memory not available\n");
+		spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+		return;
+	}
+	va_start(args, fmt);
+
+	printk_convert(e, fmt, args);
+
+	va_end(args);
+
+	list_add_tail(&e->list, &pcm_event.evtq);
+	spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+
+	schedule_work(&pcm_event.ws);
+}
+
+#ifdef	SUNXI_NETLINK_TEST
+static void sunxi_netlink_period(struct work_struct *ws)
+{
+	static int count = 1;
+	sunxi_netlink_printd("hello form the pcm netlink test: %d\n", count);
+	schedule_delayed_work(&writer_work, msecs_to_jiffies(10));
+}
+#endif
+EXPORT_SYMBOL_GPL(sunxi_netlink_printd);
+
+int sunxi_netlink_init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input = netlink_rcv,
+	};
+
+	if (!pcm_event.ref_cnt) {
+		pcm_event.sock = netlink_kernel_create(&init_net,
+					NETLINK_PCM_SUNXI, &cfg);
+		if (!pcm_event.sock) {
+			pr_err("netlink create failed\n");
+			return -EMSGSIZE;
+		}
+		if (pcm_event.sock) {
+			INIT_LIST_HEAD(&pcm_event.evtq);
+			INIT_LIST_HEAD(&pcm_event.freeq);
+			INIT_WORK(&pcm_event.ws, _pcm_event_send);
+			spin_lock_init(&pcm_event.evt_lock);
+		}
+		pcm_netlink.status = SNDRV_PCM_NETLINK_CLOSE;
+	}
+
+	if (pcm_event.sock) {
+		pcm_event.ref_cnt++;
+		pr_debug("Creating PCM netlink successfully\n");
+		return 0;
+	}
+
+	pr_debug("Creating PCM netlink is failed\n");
+	return -EBUSY;
+}
+
+static void sunxi_netlink_exit(void)
+{
+	struct evt_entry *e, *temp;
+	unsigned long flags;
+	if (pcm_event.sock && --pcm_event.ref_cnt == 0) {
+		spin_lock_irqsave(&pcm_event.evt_lock, flags);
+
+		list_for_each_entry_safe(e, temp, &pcm_event.evtq, list) {
+			list_del(&e->list);
+			free_event_entry(e);
+		}
+		list_for_each_entry_safe(e, temp, &pcm_event.freeq, list) {
+			list_del(&e->list);
+			free_event_entry(e);
+		}
+
+		spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+		netlink_kernel_release(pcm_event.sock);
+		pcm_event.sock = NULL;
+	}
+}
+
+module_init(sunxi_netlink_init);
+module_exit(sunxi_netlink_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("sunxi netlink interface");
+MODULE_ALIAS("sunxi_netlink");
diff --git a/sound/soc/sunxi/sunxi_spdif.c b/sound/soc/sunxi/sunxi_spdif.c
new file mode 100644
index 000000000..4e4702901
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_spdif.c
@@ -0,0 +1,830 @@
+/*
+ * sound\soc\sunxi\sunxi-spdif.c
+ * (C) Copyright 2014-2016
+ * allwinnertech Technology Co., Ltd. <www.allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/dma/sunxi-dma.h>
+#include <linux/pinctrl/consumer.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <linux/of_gpio.h>
+// #include <linux/sys_config.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include "sunxi_spdif.h"
+#include "sunxi_dma.h"
+
+#define	DRV_NAME	"sunxi-spdif"
+
+struct sunxi_spdif_info {
+	struct device *dev;
+	struct regmap *regmap;
+	struct mutex mutex;
+	struct clk *pllclk;
+	struct clk *moduleclk;
+	struct snd_soc_dai_driver dai;
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state  *pinstate;
+	struct pinctrl_state  *pinstate_sleep;
+	unsigned int rate;
+	unsigned int active;
+	bool configured;
+};
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+
+struct spdif_gpio_ {
+	u32 gpio;
+	bool cfg;
+};
+struct spdif_gpio_ spdif_gpio;
+
+/* Origin freq convert */
+static const struct sample_rate sample_rate_orig[] = {
+	{44100, 0xF},
+	{48000, 0xD},
+	{24000, 0x9},
+	{32000, 0xC},
+	{96000, 0x5},
+	{192000, 0x1},
+	{22050, 0xB},
+	{88200, 0x7},
+	{178400, 0x3},
+};
+
+static const struct sample_rate sample_rate_freq[] = {
+	{44100, 0x0},
+	{48000, 0x2},
+	{24000, 0x6},
+	{32000, 0x3},
+	{96000, 0xA},
+	{192000, 0xE},
+	{22050, 0x4},
+	{88200, 0x8},
+	{176400, 0xC},
+};
+
+
+static int sunxi_spdif_set_audio_mode(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dai *dai = card->rtd->cpu_dai;
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int reg_val;
+
+	regmap_read(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA0, &reg_val);
+
+	switch(ucontrol->value.integer.value[0]) {
+	case	0:
+	case	1:
+		reg_val = 0;
+		break;
+	case	2:
+		reg_val = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG,
+			(1<<TXCFG_DATA_TYPE), (reg_val<<TXCFG_DATA_TYPE));
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA0,
+			(1<<TXCHSTA0_AUDIO), (reg_val<<TXCHSTA0_AUDIO));
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCH_STA0,
+			(1<<RXCHSTA0_AUDIO), (reg_val<<RXCHSTA0_AUDIO));
+
+	return 0;
+}
+
+static int sunxi_spdif_get_audio_mode(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dai *dai = card->rtd->cpu_dai;
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int reg_val;
+
+	regmap_read(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG, &reg_val);
+	reg_val = (reg_val & (1<<TXCFG_DATA_TYPE)) ? 1 : 0;
+	ucontrol->value.integer.value[0] = reg_val + 1;
+	return 0;
+}
+
+static const char *spdif_format_function[] = {"null", "pcm", "DTS"};
+static const struct soc_enum spdif_format_enum[] = {
+        SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(spdif_format_function), spdif_format_function),
+};
+
+
+static int sunxi_spdif_get_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dai *dai = card->rtd->cpu_dai;
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int reg_val;
+
+	regmap_read(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL, &reg_val);
+
+	ucontrol->value.integer.value[0] = ((reg_val & (1<<FIFO_CTL_HUBEN)) ? 2 : 1);
+	return 0;
+}
+
+static int sunxi_spdif_set_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dai *dai = card->rtd->cpu_dai;
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+	case	1:
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(1<<FIFO_CTL_HUBEN), (0<<FIFO_CTL_HUBEN));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG,
+				(1<<TXCFG_TXEN), (0<<TXCFG_TXEN));
+		break;
+	case	2:
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(1<<FIFO_CTL_HUBEN), (1<<FIFO_CTL_HUBEN));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG,
+				(1<<TXCFG_TXEN), (1<<TXCFG_TXEN));
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+/* sunxi spdif hub mdoe select */
+static const char *spdif_hub_function[] = {"null" , "hub_disable", "hub_enable"};
+
+static const struct soc_enum spdif_hub_mode_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(spdif_hub_function),
+			spdif_hub_function),
+};
+
+/* dts pcm Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_spdif_controls[] = {
+	SOC_ENUM_EXT("spdif audio format Function", spdif_format_enum[0], sunxi_spdif_get_audio_mode, sunxi_spdif_set_audio_mode),
+
+	SOC_ENUM_EXT("sunxi spdif hub mode" , spdif_hub_mode_enum[0], sunxi_spdif_get_hub_mode, sunxi_spdif_set_hub_mode),
+};
+
+static void sunxi_spdif_txctrl_enable(struct sunxi_spdif_info *sunxi_spdif, int enable)
+{
+	if(enable) {
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG, (1<<TXCFG_TXEN), (1<<TXCFG_TXEN));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_INT, (1<<INT_TXDRQEN), (1<<INT_TXDRQEN));
+	} else {
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG, (1<<TXCFG_TXEN), (0<<TXCFG_TXEN));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_INT, (1<<INT_TXDRQEN), (0<<INT_TXDRQEN));
+	}
+}
+
+static void sunxi_spdif_rxctrl_enable(struct sunxi_spdif_info *sunxi_spdif, int enable)
+{
+	if(enable) {
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_INT, (1<<INT_RXDRQEN), (1<<INT_RXDRQEN));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCFG, (1<<RXCFG_RXEN), (1<<RXCFG_RXEN));
+	} else {
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCFG, (1<<RXCFG_RXEN), (0<<RXCFG_RXEN));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_INT, (1<<INT_RXDRQEN), (0<<INT_RXDRQEN));
+	}
+}
+
+static void sunxi_spdif_init(struct sunxi_spdif_info *sunxi_spdif)
+{
+	/* FIFO CTL register default setting */
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(CTL_TXTL_MASK<<FIFO_CTL_TXTL), (16<<FIFO_CTL_TXTL));
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(CTL_RXTL_MASK<<FIFO_CTL_RXTL), (15<<FIFO_CTL_RXTL));
+
+	regmap_write(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA0, 2<<TXCHSTA0_CHNUM);
+	regmap_write(sunxi_spdif->regmap, SUNXI_SPDIF_RXCH_STA0, 2<<RXCHSTA0_CHNUM);
+}
+
+static int sunxi_spdif_dai_hw_params(struct snd_pcm_substream *substream, 
+			struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int reg_temp;
+	unsigned int i;
+	unsigned int origin_freq_bit = 0, sample_freq_bit = 0;
+
+	/* two substream should be warking on same samplerate */
+	mutex_lock(&sunxi_spdif->mutex);
+	if(sunxi_spdif->active > 1) {
+		if(params_rate(params) != sunxi_spdif->rate) {
+			mutex_unlock(&sunxi_spdif->mutex);
+			return -EINVAL;
+		}
+	}
+	mutex_unlock(&sunxi_spdif->mutex);
+
+	switch(params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		reg_temp = 0;
+		break;
+	case	SNDRV_PCM_FORMAT_S20_3LE:
+		reg_temp = 1;
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		reg_temp = 2;
+		break;
+	default:
+		pr_debug("[sunxi-spdif]Invaild format set\n");
+		return -EINVAL;
+	}
+
+	for(i=0; i<ARRAY_SIZE(sample_rate_orig); i++) {
+		if(params_rate(params) == sample_rate_orig[i].samplerate) {
+			origin_freq_bit = sample_rate_orig[i].rate_bit;
+			break;
+		}
+	}
+
+	for(i=0; i<ARRAY_SIZE(sample_rate_freq); i++) {
+		if(params_rate(params) == sample_rate_freq[i].samplerate) {
+			sample_freq_bit = sample_rate_freq[i].rate_bit;
+			sunxi_spdif->rate = sample_rate_freq[i].samplerate;
+			break;
+		}
+	}
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG,
+			(3<<TXCFG_SAMPLE_BIT), (reg_temp<<TXCFG_SAMPLE_BIT));
+
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+					(1<<FIFO_CTL_TXIM), (1<<FIFO_CTL_TXIM));
+
+		if(params_channels(params) == 1) {
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG,
+					(1<<TXCFG_SINGLE_MOD), (1<<TXCFG_SINGLE_MOD));
+		} else {
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG,
+					(1<<TXCFG_SINGLE_MOD), (0<<TXCFG_SINGLE_MOD));
+		}
+
+		/* samplerate convertion */
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA0,
+			(0xF<<TXCHSTA0_SAMFREQ), (sample_freq_bit<<TXCHSTA0_SAMFREQ));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA1,
+			(0xF<<TXCHSTA1_ORISAMFREQ), (origin_freq_bit<<TXCHSTA1_ORISAMFREQ));
+		switch(reg_temp) {
+		case	0:
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA1,
+				(0xF<<TXCHSTA1_MAXWORDLEN), (2<<TXCHSTA1_MAXWORDLEN));
+			break;
+		case	1:
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA1,
+				(0xF<<TXCHSTA1_MAXWORDLEN), (0xC<<TXCHSTA1_MAXWORDLEN));
+			break;
+		case	2:
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCH_STA1,
+				(0xF<<TXCHSTA1_MAXWORDLEN), (0xB<<TXCHSTA1_MAXWORDLEN));
+			break;
+		default:
+			pr_debug("[sunxi-spdif]unexpection error\n");
+			return -EINVAL;
+		}
+	} else {
+		/* FIXME, not sync as spec says, just test 16bit & 24bit, using 3 working ok */
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+					(3<<FIFO_CTL_RXOM), (3<<FIFO_CTL_RXOM));
+
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCH_STA0,
+			(0xF<<RXCHSTA0_SAMFREQ), (sample_freq_bit<<RXCHSTA0_SAMFREQ));
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCH_STA1,
+			(0xF<<RXCHSTA1_ORISAMFREQ), (origin_freq_bit<<RXCHSTA1_ORISAMFREQ));
+
+		switch(reg_temp) {
+		case	0:
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCH_STA1,
+				(0xF<<RXCHSTA1_MAXWORDLEN), (2<<RXCHSTA1_MAXWORDLEN));
+			break;
+		case	1:
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCH_STA1,
+				(0xF<<RXCHSTA1_MAXWORDLEN), (0xC<<RXCHSTA1_MAXWORDLEN));
+			break;
+		case	2:
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_RXCH_STA1,
+				(0xF<<RXCHSTA1_MAXWORDLEN), (0xB<<RXCHSTA1_MAXWORDLEN));
+			break;
+		default:
+			pr_debug("[sunxi-spdif]unexpection error\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_spdif_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+						unsigned int freq, int dir)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	pr_debug("Enter %s\n", __func__);
+	mutex_lock(&sunxi_spdif->mutex);
+	if(sunxi_spdif->active == 0) {
+		pr_debug("active: %u\n", sunxi_spdif->active);
+		if(clk_set_rate(sunxi_spdif->pllclk, freq)) {
+			dev_err(sunxi_spdif->dev, "pllclk set rate to %uHz failed\n", freq);
+			mutex_unlock(&sunxi_spdif->mutex);
+			return -EBUSY;
+		}
+	}
+	sunxi_spdif->active++;
+	mutex_unlock(&sunxi_spdif->mutex);
+	pr_debug("End %s\n", __func__);
+	return 0;
+}
+
+static int sunxi_spdif_dai_set_clkdiv(struct snd_soc_dai *dai, int clk_id, int clk_div)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+
+	pr_debug("Enter %s\n", __func__);
+
+	mutex_lock(&sunxi_spdif->mutex);
+	if(sunxi_spdif->configured == false) {
+		switch(clk_id) {
+		case	0:
+			regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_TXCFG,
+				(0x1F<<TXCFG_CLK_DIV_RATIO), ((clk_div-1)<<TXCFG_CLK_DIV_RATIO));
+			break;
+		case	1:
+			break;
+		default:
+			break;
+		}
+	}
+	sunxi_spdif->configured = true;
+	mutex_unlock(&sunxi_spdif->mutex);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_spdif_dai_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_dma_data(dai, substream, &sunxi_spdif->playback_dma_param);
+	}
+	else {
+		snd_soc_dai_set_dma_data(dai, substream, &sunxi_spdif->capture_dma_param);
+	}
+
+	return 0;
+}
+
+static void sunxi_spdif_dai_shutdown(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+
+	mutex_lock(&sunxi_spdif->mutex);
+	if(sunxi_spdif->active)
+	{
+		sunxi_spdif->active--;
+		if(sunxi_spdif->active == 0)
+			sunxi_spdif->configured = false;
+	}
+	mutex_unlock(&sunxi_spdif->mutex);
+}
+
+static int sunxi_spdif_trigger(struct snd_pcm_substream *substream,
+					int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch(cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (spdif_gpio.cfg)
+			gpio_set_value(spdif_gpio.gpio, 1);
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_spdif_txctrl_enable(sunxi_spdif, 1);
+		} else {
+			sunxi_spdif_rxctrl_enable(sunxi_spdif, 1);
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_spdif_txctrl_enable(sunxi_spdif, 0);
+		} else {
+			sunxi_spdif_rxctrl_enable(sunxi_spdif, 0);
+		}
+		if (spdif_gpio.cfg)
+			gpio_set_value(spdif_gpio.gpio, 0);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_ARCH_SUN8IW10) || defined(CONFIG_ARCH_SUN50IW6)
+static bool spdif_loop_en = false;
+module_param_named(spdif_loop_en, spdif_loop_en, bool, S_IRUGO | S_IWUSR);
+#endif
+
+/* Flush FIFO & Interrupt */
+static int sunxi_spdif_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int reg_val;
+
+	/*as you need to clean up TX or RX FIFO , need to turn off GEN bit*/
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_CTL,
+			(1 << CTL_GEN_EN), (0 << CTL_GEN_EN));
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+#if defined(CONFIG_ARCH_SUN8IW10) || defined(CONFIG_ARCH_SUN50IW6)
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_CTL,
+					(1<<CTL_LOOP_EN), (spdif_loop_en<<CTL_LOOP_EN));
+#endif
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+					(1<<FIFO_CTL_FTX), (1<<FIFO_CTL_FTX));
+		regmap_write(sunxi_spdif->regmap, SUNXI_SPDIF_TXCNT, 0);
+	} else {
+		regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_FIFO_CTL,
+					(1<<FIFO_CTL_FRX), (1<<FIFO_CTL_FRX));
+		regmap_write(sunxi_spdif->regmap, SUNXI_SPDIF_RXCNT, 0);
+	}
+
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_CTL,
+			(1 << CTL_GEN_EN), (1 << CTL_GEN_EN));
+	/* clear all interrupt status */
+	regmap_read(sunxi_spdif->regmap, SUNXI_SPDIF_INT_STA, &reg_val);
+	regmap_write(sunxi_spdif->regmap, SUNXI_SPDIF_INT_STA, reg_val);
+
+	return 0;
+}
+
+static int sunxi_spdif_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	mutex_init(&sunxi_spdif->mutex);
+
+	ret = snd_soc_add_card_controls(dai->card, sunxi_spdif_controls, ARRAY_SIZE(sunxi_spdif_controls));
+	if(ret)
+		dev_warn(sunxi_spdif->dev, "Failed to register audio mode control, will continue without it.\n");
+
+	sunxi_spdif_init(sunxi_spdif);
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_CTL, (1<<CTL_GEN_EN), (1<<CTL_GEN_EN));
+
+	return 0;
+}
+
+static int sunxi_spdif_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_spdif_suspend(struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	int	ret;
+
+	pr_debug("[SPDIF]Enter %s\n", __func__);
+
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_CTL,
+				(1<<CTL_GEN_EN), (0<<CTL_GEN_EN));
+
+	if (sunxi_spdif->pinstate_sleep) {
+		ret = pinctrl_select_state(sunxi_spdif->pinctrl, sunxi_spdif->pinstate_sleep);
+		if(ret) {
+			dev_err(sunxi_spdif->dev, "pinstate sleep select failed\n");
+			return ret;
+		}
+	}
+
+	if (sunxi_spdif->pinctrl != NULL)
+		devm_pinctrl_put(sunxi_spdif->pinctrl);
+
+	pr_debug("[sunxi-spdif]sunxi_spdif->clk_enable: %d\n",sunxi_spdif->active);
+
+	sunxi_spdif->pinctrl = NULL;
+	sunxi_spdif->pinstate = NULL;
+	sunxi_spdif->pinstate_sleep = NULL;
+	if(sunxi_spdif->moduleclk != NULL)
+		clk_disable_unprepare(sunxi_spdif->moduleclk);
+	if(sunxi_spdif->pllclk != NULL)
+		clk_disable_unprepare(sunxi_spdif->pllclk);
+
+	pr_debug("[SPDIF]End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_spdif_resume(struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	int	ret;
+
+	pr_debug("[sunxi-spdif]Enter %s\n", __func__);
+
+	if(sunxi_spdif->pllclk != NULL)
+		ret = clk_prepare_enable(sunxi_spdif->pllclk);
+	if(sunxi_spdif->moduleclk != NULL)
+		clk_prepare_enable(sunxi_spdif->moduleclk);
+
+	if(sunxi_spdif->pinctrl == NULL) {
+		sunxi_spdif->pinctrl = devm_pinctrl_get(sunxi_spdif->dev);
+		if(IS_ERR_OR_NULL(sunxi_spdif->pinctrl)) {
+			dev_err(sunxi_spdif->dev, "Can't get sunxi spdif pinctrl\n");
+			return -EBUSY;
+		}
+	}
+
+	if (!sunxi_spdif->pinstate) {
+		sunxi_spdif->pinstate = pinctrl_lookup_state(sunxi_spdif->pinctrl, PINCTRL_STATE_DEFAULT);
+		if(IS_ERR_OR_NULL(sunxi_spdif->pinstate)) {
+			dev_err(sunxi_spdif->dev, "Can't get sunxi spdif pinctrl default state\n");
+			return -EBUSY;
+		}
+	}
+
+	if (!sunxi_spdif->pinstate_sleep) {
+		sunxi_spdif->pinstate_sleep = pinctrl_lookup_state(sunxi_spdif->pinctrl, PINCTRL_STATE_SLEEP);
+		if(IS_ERR_OR_NULL(sunxi_spdif->pinstate_sleep)) {
+			dev_err(sunxi_spdif->dev, "Can't get sunxi spdif pinctrl sleep state\n");
+			return -EINVAL;
+		}
+	}
+
+	ret = pinctrl_select_state(sunxi_spdif->pinctrl, sunxi_spdif->pinstate);
+	if(ret) {
+		dev_err(sunxi_spdif->dev, "select pin default state failed\n");
+		return ret;
+	}
+
+	sunxi_spdif_init(sunxi_spdif);
+	regmap_update_bits(sunxi_spdif->regmap, SUNXI_SPDIF_CTL,
+				(1<<CTL_GEN_EN), (1<<CTL_GEN_EN));
+
+	pr_debug("[sunxi-spdif]End %s\n", __func__);
+	return 0;
+}
+
+#define SUNXI_SPDIF_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_spdif_dai_ops = {
+	.hw_params 	= sunxi_spdif_dai_hw_params,
+	.set_clkdiv 	= sunxi_spdif_dai_set_clkdiv,
+	.set_sysclk 	= sunxi_spdif_dai_set_sysclk,
+	.startup	= sunxi_spdif_dai_startup,
+	.shutdown	= sunxi_spdif_dai_shutdown,
+	.trigger 	= sunxi_spdif_trigger,
+	.prepare	= sunxi_spdif_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_spdif_dai = {
+	.probe 		= sunxi_spdif_probe,
+	.suspend 	= sunxi_spdif_suspend,
+	.resume 	= sunxi_spdif_resume,
+	.remove		= sunxi_spdif_remove,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_SPDIF_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S20_3LE| SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_SPDIF_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE|SNDRV_PCM_FMTBIT_S20_3LE| SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &sunxi_spdif_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_spdif_component = {
+	.name		= DRV_NAME,
+};
+
+static const struct regmap_config sunxi_spdif_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_SPDIF_RXCH_STA1,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int  sunxi_spdif_dev_probe(struct platform_device *pdev)
+{
+	struct resource res, *memregion;
+	struct device_node *node = pdev->dev.of_node;
+	void __iomem *sunxi_spdif_membase;
+	struct sunxi_spdif_info *sunxi_spdif;
+	struct gpio_config config;
+	int	ret;
+
+	sunxi_spdif = devm_kzalloc(&pdev->dev, sizeof(struct sunxi_spdif_info), GFP_KERNEL);
+	if(!sunxi_spdif) {
+		dev_err(&pdev->dev, "Can't allocate sunxi_spdif memory\n");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_spdif);
+	sunxi_spdif->dev = &pdev->dev;
+	sunxi_spdif->dai = sunxi_spdif_dai;
+	sunxi_spdif->dai.name = dev_name(&pdev->dev);
+
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't parse device node resource\n");
+		return -ENODEV;
+	}
+
+	memregion = devm_request_mem_region(&pdev->dev, res.start,
+					    resource_size(&res), DRV_NAME);
+	if (memregion == NULL) {
+		dev_err(&pdev->dev, "Memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_kfree;
+	}
+
+	sunxi_spdif_membase = ioremap(res.start, resource_size(&res));
+	if(sunxi_spdif_membase == NULL) {
+		dev_err(&pdev->dev, "Can't remap sunxi spdif registers\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	sunxi_spdif->regmap = devm_regmap_init_mmio(&pdev->dev, sunxi_spdif_membase, &sunxi_spdif_regmap_config);
+	if(IS_ERR(sunxi_spdif->regmap)) {
+		dev_err(&pdev->dev, "regmap sunxi spdif membase failed\n");
+		ret = PTR_ERR(sunxi_spdif->regmap);
+		goto err_iounmap;
+	}
+
+	sunxi_spdif->pllclk = of_clk_get(node, 0);
+	sunxi_spdif->moduleclk = of_clk_get(node, 1);
+	if (IS_ERR(sunxi_spdif->pllclk) || IS_ERR(sunxi_spdif->moduleclk)){
+		dev_err(&pdev->dev, "Can't get spdif clocks\n");
+		if (IS_ERR(sunxi_spdif->pllclk)) {
+			ret = PTR_ERR(sunxi_spdif->pllclk);
+			goto err_iounmap;
+		}
+		else {
+			ret = PTR_ERR(sunxi_spdif->moduleclk);
+			goto err_pllclk_put;
+		}
+	} else {
+		if (clk_set_parent(sunxi_spdif->moduleclk, sunxi_spdif->pllclk)) {
+			dev_err(&pdev->dev, "set parent of moduleclk to pllclk failed! line = %d\n",__LINE__);
+		}
+		clk_prepare_enable(sunxi_spdif->pllclk);
+		clk_prepare_enable(sunxi_spdif->moduleclk);
+	}
+
+	sunxi_spdif->playback_dma_param.dma_addr = res.start + SUNXI_SPDIF_TXFIFO;
+	sunxi_spdif->playback_dma_param.dma_drq_type_num = DRQDST_SPDIFTX;
+	sunxi_spdif->playback_dma_param.dst_maxburst = 8;
+	sunxi_spdif->playback_dma_param.src_maxburst = 8;
+
+	sunxi_spdif->capture_dma_param.dma_addr = res.start + SUNXI_SPDIF_RXFIFO;
+	sunxi_spdif->capture_dma_param.dma_drq_type_num = DRQSRC_SPDIFRX;
+	sunxi_spdif->capture_dma_param.src_maxburst = 8;
+	sunxi_spdif->capture_dma_param.dst_maxburst = 8;
+
+	sunxi_spdif->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR_OR_NULL(sunxi_spdif->pinctrl)) {
+		dev_err(&pdev->dev, "request pinctrl handle for audio failed\n");
+		ret = -EINVAL;
+		goto err_moduleclk_put;
+	}
+
+	sunxi_spdif->pinstate = pinctrl_lookup_state(sunxi_spdif->pinctrl, PINCTRL_STATE_DEFAULT);
+	if (IS_ERR_OR_NULL(sunxi_spdif->pinstate)) {
+		dev_err(&pdev->dev, "lookup pin default state failed\n");
+		ret = -EINVAL;
+		goto err_pinctrl_put;
+	}
+
+	sunxi_spdif->pinstate_sleep = pinctrl_lookup_state(sunxi_spdif->pinctrl, PINCTRL_STATE_SLEEP);
+	if (IS_ERR_OR_NULL(sunxi_spdif->pinstate_sleep)) {
+		dev_err (&pdev->dev, "lookup pin sleep state failed\n");
+		ret = -EINVAL;
+		goto err_pinctrl_put;
+	}
+	/*initial speaker gpio */
+	spdif_gpio.gpio = of_get_named_gpio_flags(node, "gpio-spdif", 0, (enum of_gpio_flags *)&config);
+	if (!gpio_is_valid(spdif_gpio.gpio)) {
+		pr_err("failed to get gpio-spdif gpio from dts,spdif_gpio:%d\n", spdif_gpio.gpio);
+		spdif_gpio.cfg = 0;
+	} else {
+		ret = devm_gpio_request(&pdev->dev, spdif_gpio.gpio, "SPDIF");
+		if (ret) {
+			spdif_gpio.cfg = 0;
+			pr_err("failed to request gpio-spdif gpio\n");
+		} else {
+			spdif_gpio.cfg = 1;
+			gpio_direction_output(spdif_gpio.gpio, 0);
+		}
+	}
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_spdif_component, &sunxi_spdif->dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_pinctrl_put;
+	}
+
+	ret = asoc_dma_platform_register(&pdev->dev,0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_unregister_component;
+	}
+
+	return 0;
+
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_pinctrl_put:
+	devm_pinctrl_put(sunxi_spdif->pinctrl);
+err_moduleclk_put:
+	clk_put(sunxi_spdif->moduleclk);
+err_pllclk_put:
+	clk_put(sunxi_spdif->pllclk);
+err_iounmap:
+	iounmap(sunxi_spdif_membase);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_spdif);
+err_node_put:
+	of_node_put(node);
+	return ret;
+}
+
+static int __exit sunxi_spdif_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	clk_put(sunxi_spdif->moduleclk);
+	clk_put(sunxi_spdif->pllclk);
+	devm_kfree(&pdev->dev, sunxi_spdif);
+	return 0;
+}
+
+static const struct of_device_id sunxi_spdif_of_match[] = {
+	{ .compatible = "allwinner,sunxi-spdif", },
+	{},
+};
+
+static struct platform_driver sunxi_spdif_driver = {
+	.probe = sunxi_spdif_dev_probe,
+	.remove = __exit_p(sunxi_spdif_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_spdif_of_match,
+	},
+};
+
+module_platform_driver(sunxi_spdif_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI SPDIF ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-spdif");
diff --git a/sound/soc/sunxi/sunxi_spdif.h b/sound/soc/sunxi/sunxi_spdif.h
new file mode 100644
index 000000000..46533b0ff
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_spdif.h
@@ -0,0 +1,197 @@
+/*
+ * sound\soc\sunxi\spdif\sunxi_spdif.h
+ * (C) Copyright 2010-2016
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef	__SUNXI_SPDIF_H_
+#define	__SUNXI_SPDIF_H_
+
+/* SPDIF register definition */
+#define	SUNXI_SPDIF_CTL		0x00
+#define	SUNXI_SPDIF_TXCFG	0x04
+#define	SUNXI_SPDIF_RXCFG	0x08
+#if	defined(CONFIG_ARCH_SUN9IW1) || \
+	defined(CONFIG_ARCH_SUN8IW6) || \
+	defined(CONFIG_ARCH_SUN8IW7) || \
+	defined(CONFIG_ARCH_SUN50I) || \
+	defined(CONFIG_ARCH_SUN8IW10) || \
+	defined(CONFIG_ARCH_SUN8IW11)
+#define SUNXI_SPDIF_TXFIFO (0x20)
+#else
+#define SUNXI_SPDIF_TXFIFO (0x0C)
+#endif
+#define	SUNXI_SPDIF_RXFIFO	0x10
+#define	SUNXI_SPDIF_FIFO_CTL	0x14
+#define	SUNXI_SPDIF_FIFO_STA	0x18
+#define	SUNXI_SPDIF_INT		0x1C
+#if	defined(CONFIG_ARCH_SUN9IW1) || \
+	defined(CONFIG_ARCH_SUN8IW6) || \
+	defined(CONFIG_ARCH_SUN8IW7) || \
+	defined(CONFIG_ARCH_SUN50I) || \
+	defined(CONFIG_ARCH_SUN8IW10) || \
+	defined(CONFIG_ARCH_SUN8IW11)
+#define SUNXI_SPDIF_INT_STA (0x0C)
+#else
+#define SUNXI_SPDIF_INT_STA (0x20)
+#endif
+#define	SUNXI_SPDIF_TXCNT	0x24
+#define	SUNXI_SPDIF_RXCNT	0x28
+#define	SUNXI_SPDIF_TXCH_STA0	0x2C
+#define	SUNXI_SPDIF_TXCH_STA1	0x30
+#define	SUNXI_SPDIF_RXCH_STA0	0x34
+#define	SUNXI_SPDIF_RXCH_STA1	0x38
+
+/* SUNXI_SPDIF_CTL register */
+#define	CTL_RESET		0
+#define	CTL_GEN_EN		1
+#if	defined(CONFIG_ARCH_SUN8IW1)
+#define	CTL_MCLKOUTEN		2
+#elif	defined(CONFIG_ARCH_SUN50IW6)
+#define CTL_MCLKOOUTEN		3
+#endif
+#if	defined(CONFIG_ARCH_SUN8IW10) || \
+	defined(CONFIG_ARCH_SUN50IW6)
+#define	CTL_LOOP_EN		2
+#endif
+
+#if	defined(CONFIG_ARCH_SUN50IW6)
+#define	CTL_MCLKDIV		5
+#elif	defined(CONFIG_ARCH_SUN8IW1) || \
+	defined(CONFIG_ARCH_SUN8IW7) || \
+	defined(CONFIG_ARCH_SUN50I) || \
+	defined(CONFIG_ARCH_SUN8IW11)
+#define	CTL_MCLKDIV		4
+#endif
+
+/* SUNXI_SPDIF_TXCFG register */
+#define	TXCFG_TXEN		0
+/* Chan status generated form TX_CHSTA */
+#define	TXCFG_CHAN_STA_EN	1
+#define	TXCFG_SAMPLE_BIT	2
+#define	TXCFG_CLK_DIV_RATIO	4
+#define	TXCFG_DATA_TYPE		16
+/* Only valid in PCM mode */
+#define	TXCFG_ASS		17
+#define	TXCFG_SINGLE_MOD	31
+
+/* SUNXI_SPDIF_RXCFG register */
+#define	RXCFG_RXEN		0
+#define	RXCFG_CHSR_CP		1
+#define	RXCFG_CHST_SRC		3
+#define	RXCFG_LOCK_FLAG		4
+
+/* SUNXI_SPDIF_FIFO_CTL register */
+#define	FIFO_CTL_RXOM		0
+#define	FIFO_CTL_TXIM		2
+#if	defined(CONFIG_ARCH_SUN8IW10) || \
+	defined(CONFIG_ARCH_SUN50IW6)
+#define	FIFO_CTL_RXTL		4
+#define	FIFO_CTL_TXTL		12
+#define	FIFO_CTL_FRX		29
+#define	FIFO_CTL_FTX		30
+#else
+#define	FIFO_CTL_RXTL		3
+#define	FIFO_CTL_TXTL		8
+#define	FIFO_CTL_FRX		16
+#define	FIFO_CTL_FTX		17
+#endif
+#if	defined(CONFIG_ARCH_SUN9IW1) || \
+	defined(CONFIG_ARCH_SUN8IW6) || \
+	defined(CONFIG_ARCH_SUN8IW7) || \
+	defined(CONFIG_ARCH_SUN50I) || \
+	defined(CONFIG_ARCH_SUN8IW10) || \
+	defined(CONFIG_ARCH_SUN8IW11)
+#define	FIFO_CTL_HUBEN		31
+#else
+#define	FIFO_CTL_SRC		31
+#endif
+#if	defined(CONFIG_ARCH_SUN8IW10) || \
+	defined(CONFIG_ARCH_SUN50IW6)
+#define	CTL_TXTL_MASK		255
+#define	CTL_RXTL_MASK		127	
+#else
+#define	CTL_TXTL_MASK		31
+#define	CTL_RXTL_MASK		31
+#endif
+
+/* SUNXI_SPDIF_FIFO_STA register */
+#define	FIFO_STA_RXA_CNT	0
+#if	defined(CONFIG_ARCH_SUN8IW10) || \
+	defined(CONFIG_ARCH_SUN50IW6)
+#define	FIFO_STA_RXA		15
+#define	FIFO_STA_TXA_CNT	16
+#define	FIFO_STA_TXE		31
+#else
+#define	FIFO_STA_RXA		6
+#define	FIFO_STA_TXA_CNT	8
+#define	FIFO_STA_TXE		14
+#endif
+
+/* SUNXI_SPDIF_INT register */
+#define	INT_RXAIEN		0
+#define	INT_RXOIEN		1
+#define	INT_RXDRQEN		2
+#define	INT_TXEIEN		4
+#define	INT_TXOIEN		5
+#define	INT_TXUIEN		6
+#define	INT_TXDRQEN		7
+#define	INT_RXPAREN		16
+#define	INT_RXUNLOCKEN		17
+#define	INT_RXLOCKEN		18
+
+/* SUNXI_SPDIF_INT_STA  */
+#define	INT_STA_RXA		0
+#define	INT_STA_STO		1
+#define	INT_STA_TXE		4
+#define	INT_STA_TXO		5
+#define	INT_STA_TXU		6
+#define	INT_STA_RXPAR		16
+#define	INT_STA_RXUNLOCK	17
+#define	INT_STA_RXLOCK		18
+
+/* SUNXI_SPDIF_TXCH_STA0 register */
+#define	TXCHSTA0_PRO		0
+#define	TXCHSTA0_AUDIO		1
+#define	TXCHSTA0_CP		2
+#define	TXCHSTA0_EMPHASIS	3
+#define	TXCHSTA0_MODE		6
+#define	TXCHSTA0_CATACOD	8
+#define	TXCHSTA0_SRCNUM		16
+#define	TXCHSTA0_CHNUM		20
+#define	TXCHSTA0_SAMFREQ	24
+#define	TXCHSTA0_CLK		28
+
+/* SUNXI_SPDIF_TXCH_STA1 register */
+#define	TXCHSTA1_MAXWORDLEN	0
+#define	TXCHSTA1_SAMWORDLEN	1
+#define	TXCHSTA1_ORISAMFREQ	4
+#define	TXCHSTA1_CGMSA		8
+
+/* SUNXI_SPDIF_RXCH_STA0 register */
+#define	RXCHSTA0_PRO		0
+#define	RXCHSTA0_AUDIO		1
+#define	RXCHSTA0_CP			2
+#define	RXCHSTA0_EMPHASIS	3
+#define	RXCHSTA0_MODE		6
+#define	RXCHSTA0_CATACOD	8
+#define	RXCHSTA0_SRCNUM		16
+#define	RXCHSTA0_CHNUM		20
+#define	RXCHSTA0_SAMFREQ	24
+#define	RXCHSTA0_CLK		28
+
+/* SUNXI_SPDIF_RXCH_STA1 register */
+#define	RXCHSTA1_MAXWORDLEN	0
+#define	RXCHSTA1_SAMWORDLEN	1
+#define	RXCHSTA1_ORISAMFREQ	4
+#define	RXCHSTA1_CGMSA		8
+#endif	/* __SUNXI_SPDIF_H_ */
-- 
2.17.1

