From e818ec854c2537da23db40757f43bb5ef0aaf99b Mon Sep 17 00:00:00 2001
From: Zhang Guipeng <zhangguipeng4455@gmail.com>
Date: Wed, 9 May 2018 02:28:53 -0700
Subject: [PATCH 1/2] rtc-sunxi driver added

---
 drivers/rtc/Kconfig     |  2 +-
 drivers/rtc/rtc-sunxi.c | 57 ++++++++++++++++++++++++++++++++-----------------
 2 files changed, 38 insertions(+), 21 deletions(-)

diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index e0e58f3..f2d97b9 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1471,7 +1471,7 @@ config RTC_DRV_SUN6I
 
 config RTC_DRV_SUNXI
 	tristate "Allwinner sun4i/sun7i RTC"
-	depends on MACH_SUN4I || MACH_SUN7I || COMPILE_TEST
+	depends on MACH_SUN4I || MACH_SUN7I || ARCH_SUNXI || COMPILE_TEST
 	help
 	  If you say Y here you will get support for the RTC found on
 	  Allwinner A10/A20.
diff --git a/drivers/rtc/rtc-sunxi.c b/drivers/rtc/rtc-sunxi.c
index abada60..fbefc59 100644
--- a/drivers/rtc/rtc-sunxi.c
+++ b/drivers/rtc/rtc-sunxi.c
@@ -33,25 +33,32 @@
 #include <linux/rtc.h>
 #include <linux/types.h>
 
+
+/* Control register */
 #define SUNXI_LOSC_CTRL				0x0000
+#define SUNXI_LOSC_CTRL_KEY			(0x16aa << 16)
 #define SUNXI_LOSC_CTRL_RTC_HMS_ACC		BIT(8)
-#define SUNXI_LOSC_CTRL_RTC_YMD_ACC		BIT(7)
-
-#define SUNXI_RTC_YMD				0x0004
-
-#define SUNXI_RTC_HMS				0x0008
+#define SUNXI_LOSC_CTRL_RTC_YMD_ACC		BIT(7)						
 
-#define SUNXI_ALRM_DHMS				0x000c
+/* RTC */
+#define SUNXI_RTC_YMD				0x0010
+#define SUNXI_RTC_HMS				0x0014
 
-#define SUNXI_ALRM_EN				0x0014
-#define SUNXI_ALRM_EN_CNT_EN			BIT(8)
-
-#define SUNXI_ALRM_IRQ_EN			0x0018
+/* Alarm 0 */
+#define SUNXI_ALRM_CNT				0x0020
+#define SUNXI_ALRM_EN				0x0028
+#define SUNXI_ALRM_EN_CNT_EN		BIT(0)
+#define SUNXI_ALRM_IRQ_EN			0x002c
 #define SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN		BIT(0)
-
-#define SUNXI_ALRM_IRQ_STA			0x001c
+#define SUNXI_ALRM_IRQ_STA			0x0030
 #define SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND		BIT(0)
 
+/* Alarm 1 */
+#define SUNXI_ALRM1_WHMS			0x0040
+#define SUNXI_ALRM1_EN				0x0044
+#define SUNXI_ALRM1_IRQ_EN			0x0048
+#define SUNXI_ALRM1_IRQ_STA			0x004c
+
 #define SUNXI_MASK_DH				0x0000001f
 #define SUNXI_MASK_SM				0x0000003f
 #define SUNXI_MASK_M				0x0000000f
@@ -146,6 +153,12 @@ static const struct sunxi_rtc_data_year data_year_param[] = {
 		.mask		= 0xff,
 		.leap_shift	= 24,
 	},
+	[2] = {
+		.min		= 2018,
+		.max		= 2081,
+		.mask		= 0x3f,
+		.leap_shift	= 22,
+	},
 };
 
 struct sunxi_rtc_dev {
@@ -203,7 +216,7 @@ static int sunxi_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)
 	u32 alrm_en;
 	u32 date;
 
-	alrm = readl(chip->base + SUNXI_ALRM_DHMS);
+	alrm = readl(chip->base + SUNXI_ALRM_CNT);
 	date = readl(chip->base + SUNXI_RTC_YMD);
 
 	alrm_tm->tm_sec = SUNXI_ALRM_GET_SEC_VALUE(alrm);
@@ -303,14 +316,14 @@ static int sunxi_rtc_setalarm(struct device *dev, struct rtc_wkalrm *wkalrm)
 	time_gap -= time_gap_min * SEC_IN_MIN;
 
 	sunxi_rtc_setaie(0, chip);
-	writel(0, chip->base + SUNXI_ALRM_DHMS);
+	writel(0, chip->base + SUNXI_ALRM_CNT);
 	usleep_range(100, 300);
 
 	alrm = SUNXI_ALRM_SET_SEC_VALUE(time_gap) |
 		SUNXI_ALRM_SET_MIN_VALUE(time_gap_min) |
 		SUNXI_ALRM_SET_HOUR_VALUE(time_gap_hour) |
 		SUNXI_ALRM_SET_DAY_VALUE(time_gap_day);
-	writel(alrm, chip->base + SUNXI_ALRM_DHMS);
+	writel(alrm, chip->base + SUNXI_ALRM_CNT);
 
 	writel(0, chip->base + SUNXI_ALRM_IRQ_EN);
 	writel(SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN, chip->base + SUNXI_ALRM_IRQ_EN);
@@ -330,7 +343,7 @@ static int sunxi_rtc_wait(struct sunxi_rtc_dev *chip, int offset,
 		reg = readl(chip->base + offset);
 		reg &= mask;
 
-		if (reg == mask)
+		if (!reg)
 			return 0;
 
 	} while (time_before(jiffies, timeout));
@@ -373,9 +386,6 @@ static int sunxi_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)
 		SUNXI_TIME_SET_MIN_VALUE(rtc_tm->tm_min)  |
 		SUNXI_TIME_SET_HOUR_VALUE(rtc_tm->tm_hour);
 
-	writel(0, chip->base + SUNXI_RTC_HMS);
-	writel(0, chip->base + SUNXI_RTC_YMD);
-
 	writel(time, chip->base + SUNXI_RTC_HMS);
 
 	/*
@@ -428,6 +438,7 @@ static const struct rtc_class_ops sunxi_rtc_ops = {
 static const struct of_device_id sunxi_rtc_dt_ids[] = {
 	{ .compatible = "allwinner,sun4i-a10-rtc", .data = &data_year_param[0] },
 	{ .compatible = "allwinner,sun7i-a20-rtc", .data = &data_year_param[1] },
+	{ .compatible = "allwinner,sun50i-h6-rtc", .data = &data_year_param[2] },
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, sunxi_rtc_dt_ids);
@@ -468,8 +479,14 @@ static int sunxi_rtc_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	/* writing key field*/
+	writel(SUNXI_LOSC_CTRL_KEY | 0x4000, chip->base + SUNXI_LOSC_CTRL);
+
+	/* select external clock */
+	writel(SUNXI_LOSC_CTRL_KEY | 0x4011, chip->base + SUNXI_LOSC_CTRL);
+
 	/* clear the alarm count value */
-	writel(0, chip->base + SUNXI_ALRM_DHMS);
+	writel(0, chip->base + SUNXI_ALRM_CNT);
 
 	/* disable alarm, not generate irq pending */
 	writel(0, chip->base + SUNXI_ALRM_EN);
-- 
2.7.4

